
Lab 4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800200  00002098  0000212c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002098  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000189d  00800210  00800210  0000213c  2**0
                  ALLOC
  3 .stab         000008a0  00000000  00000000  0000213c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  000029dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00002b88  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002870  00000000  00000000  00002d28  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b3a  00000000  00000000  00005598  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000010d7  00000000  00000000  000060d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008f8  00000000  00000000  000071ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000104e  00000000  00000000  00007aa4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000259a  00000000  00000000  00008af2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  0000b08c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
       c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      1c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      20:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      34:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      54:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      58:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      5c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      60:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      64:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      68:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      6c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      70:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      74:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      78:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      7c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      80:	0c 94 0a 06 	jmp	0xc14	; 0xc14 <__vector_32>
      84:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      88:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      8c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      90:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      94:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      98:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      9c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      a8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      ac:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      b8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      bc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      c8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      cc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      d8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      dc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
      e0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e8 e9       	ldi	r30, 0x98	; 152
      fc:	f0 e2       	ldi	r31, 0x20	; 32
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a0 31       	cpi	r26, 0x10	; 16
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
     10e:	1b be       	out	0x3b, r1	; 59

00000110 <__do_clear_bss>:
     110:	1a e1       	ldi	r17, 0x1A	; 26
     112:	a0 e1       	ldi	r26, 0x10	; 16
     114:	b2 e0       	ldi	r27, 0x02	; 2
     116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
     118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
     11a:	ad 3a       	cpi	r26, 0xAD	; 173
     11c:	b1 07       	cpc	r27, r17
     11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>
     120:	0e 94 49 03 	call	0x692	; 0x692 <main>
     124:	0c 94 4a 10 	jmp	0x2094	; 0x2094 <_exit>

00000128 <__bad_interrupt>:
     128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <vIO_init>:
* return: void
*--------------------------------------------------------*/
void vIO_init(void)
{
	// Set PortA (LEDs) as all outputs
	DDRA = 0xFF;
     12c:	8f ef       	ldi	r24, 0xFF	; 255
     12e:	81 b9       	out	0x01, r24	; 1
	// Turn LEDs off
	PORTA = 0xFF;
     130:	82 b9       	out	0x02, r24	; 2
}
     132:	08 95       	ret

00000134 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     134:	af 92       	push	r10
     136:	bf 92       	push	r11
     138:	cf 92       	push	r12
     13a:	df 92       	push	r13
     13c:	ef 92       	push	r14
     13e:	ff 92       	push	r15
     140:	0f 93       	push	r16
     142:	1f 93       	push	r17
     144:	cf 93       	push	r28
     146:	df 93       	push	r29
     148:	6c 01       	movw	r12, r24
     14a:	e6 2e       	mov	r14, r22
     14c:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     14e:	8a e1       	ldi	r24, 0x1A	; 26
     150:	90 e0       	ldi	r25, 0x00	; 0
     152:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
     156:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     158:	00 97       	sbiw	r24, 0x00	; 0
     15a:	09 f4       	brne	.+2      	; 0x15e <xCoRoutineCreate+0x2a>
     15c:	62 c0       	rjmp	.+196    	; 0x222 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     15e:	80 91 10 02 	lds	r24, 0x0210
     162:	90 91 11 02 	lds	r25, 0x0211
     166:	00 97       	sbiw	r24, 0x00	; 0
     168:	39 f5       	brne	.+78     	; 0x1b8 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     16a:	10 93 11 02 	sts	0x0211, r17
     16e:	00 93 10 02 	sts	0x0210, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     172:	c3 e1       	ldi	r28, 0x13	; 19
     174:	d2 e0       	ldi	r29, 0x02	; 2
     176:	ce 01       	movw	r24, r28
     178:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
     17c:	ce 01       	movw	r24, r28
     17e:	09 96       	adiw	r24, 0x09	; 9
     180:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     184:	c5 e2       	ldi	r28, 0x25	; 37
     186:	d2 e0       	ldi	r29, 0x02	; 2
     188:	ce 01       	movw	r24, r28
     18a:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     18e:	0f 2e       	mov	r0, r31
     190:	fe e2       	ldi	r31, 0x2E	; 46
     192:	af 2e       	mov	r10, r31
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	bf 2e       	mov	r11, r31
     198:	f0 2d       	mov	r31, r0
     19a:	c5 01       	movw	r24, r10
     19c:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     1a0:	87 e3       	ldi	r24, 0x37	; 55
     1a2:	92 e0       	ldi	r25, 0x02	; 2
     1a4:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     1a8:	d0 93 41 02 	sts	0x0241, r29
     1ac:	c0 93 40 02 	sts	0x0240, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     1b0:	b0 92 43 02 	sts	0x0243, r11
     1b4:	a0 92 42 02 	sts	0x0242, r10
     1b8:	ce 2d       	mov	r28, r14
     1ba:	e1 10       	cpse	r14, r1
     1bc:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1be:	f8 01       	movw	r30, r16
     1c0:	11 8e       	std	Z+25, r1	; 0x19
     1c2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1c4:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1c6:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1c8:	c1 92       	st	Z+, r12
     1ca:	d1 92       	st	Z+, r13
     1cc:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1ce:	cf 01       	movw	r24, r30
     1d0:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1d4:	c8 01       	movw	r24, r16
     1d6:	0c 96       	adiw	r24, 0x0c	; 12
     1d8:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1dc:	f8 01       	movw	r30, r16
     1de:	11 87       	std	Z+9, r17	; 0x09
     1e0:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1e2:	13 8b       	std	Z+19, r17	; 0x13
     1e4:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     1e6:	84 e0       	ldi	r24, 0x04	; 4
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	8c 1b       	sub	r24, r28
     1ec:	91 09       	sbc	r25, r1
     1ee:	95 87       	std	Z+13, r25	; 0x0d
     1f0:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1f2:	86 89       	ldd	r24, Z+22	; 0x16
     1f4:	90 91 12 02 	lds	r25, 0x0212
     1f8:	98 17       	cp	r25, r24
     1fa:	10 f4       	brcc	.+4      	; 0x200 <xCoRoutineCreate+0xcc>
     1fc:	80 93 12 02 	sts	0x0212, r24
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	9c 01       	movw	r18, r24
     204:	22 0f       	add	r18, r18
     206:	33 1f       	adc	r19, r19
     208:	22 0f       	add	r18, r18
     20a:	33 1f       	adc	r19, r19
     20c:	22 0f       	add	r18, r18
     20e:	33 1f       	adc	r19, r19
     210:	82 0f       	add	r24, r18
     212:	93 1f       	adc	r25, r19
     214:	8d 5e       	subi	r24, 0xED	; 237
     216:	9d 4f       	sbci	r25, 0xFD	; 253
     218:	b7 01       	movw	r22, r14
     21a:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>

		xReturn = pdPASS;
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	01 c0       	rjmp	.+2      	; 0x224 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     222:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     224:	df 91       	pop	r29
     226:	cf 91       	pop	r28
     228:	1f 91       	pop	r17
     22a:	0f 91       	pop	r16
     22c:	ff 90       	pop	r15
     22e:	ef 90       	pop	r14
     230:	df 90       	pop	r13
     232:	cf 90       	pop	r12
     234:	bf 90       	pop	r11
     236:	af 90       	pop	r10
     238:	08 95       	ret

0000023a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     23a:	0f 93       	push	r16
     23c:	1f 93       	push	r17
     23e:	cf 93       	push	r28
     240:	df 93       	push	r29
     242:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     244:	c0 91 44 02 	lds	r28, 0x0244
     248:	d0 91 45 02 	lds	r29, 0x0245
     24c:	c8 0f       	add	r28, r24
     24e:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     250:	80 91 10 02 	lds	r24, 0x0210
     254:	90 91 11 02 	lds	r25, 0x0211
     258:	02 96       	adiw	r24, 0x02	; 2
     25a:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     25e:	e0 91 10 02 	lds	r30, 0x0210
     262:	f0 91 11 02 	lds	r31, 0x0211
     266:	d3 83       	std	Z+3, r29	; 0x03
     268:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     26a:	80 91 44 02 	lds	r24, 0x0244
     26e:	90 91 45 02 	lds	r25, 0x0245
     272:	c8 17       	cp	r28, r24
     274:	d9 07       	cpc	r29, r25
     276:	50 f4       	brcc	.+20     	; 0x28c <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     278:	bf 01       	movw	r22, r30
     27a:	6e 5f       	subi	r22, 0xFE	; 254
     27c:	7f 4f       	sbci	r23, 0xFF	; 255
     27e:	80 91 42 02 	lds	r24, 0x0242
     282:	90 91 43 02 	lds	r25, 0x0243
     286:	0e 94 0a 04 	call	0x814	; 0x814 <vListInsert>
     28a:	09 c0       	rjmp	.+18     	; 0x29e <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     28c:	bf 01       	movw	r22, r30
     28e:	6e 5f       	subi	r22, 0xFE	; 254
     290:	7f 4f       	sbci	r23, 0xFF	; 255
     292:	80 91 40 02 	lds	r24, 0x0240
     296:	90 91 41 02 	lds	r25, 0x0241
     29a:	0e 94 0a 04 	call	0x814	; 0x814 <vListInsert>
	}

	if( pxEventList )
     29e:	01 15       	cp	r16, r1
     2a0:	11 05       	cpc	r17, r1
     2a2:	49 f0       	breq	.+18     	; 0x2b6 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2a4:	60 91 10 02 	lds	r22, 0x0210
     2a8:	70 91 11 02 	lds	r23, 0x0211
     2ac:	64 5f       	subi	r22, 0xF4	; 244
     2ae:	7f 4f       	sbci	r23, 0xFF	; 255
     2b0:	c8 01       	movw	r24, r16
     2b2:	0e 94 0a 04 	call	0x814	; 0x814 <vListInsert>
	}
}
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	1f 91       	pop	r17
     2bc:	0f 91       	pop	r16
     2be:	08 95       	ret

000002c0 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     2c0:	cf 92       	push	r12
     2c2:	df 92       	push	r13
     2c4:	ef 92       	push	r14
     2c6:	ff 92       	push	r15
     2c8:	0f 93       	push	r16
     2ca:	1f 93       	push	r17
     2cc:	cf 93       	push	r28
     2ce:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2d0:	80 91 37 02 	lds	r24, 0x0237
     2d4:	88 23       	and	r24, r24
     2d6:	b9 f1       	breq	.+110    	; 0x346 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2d8:	0f 2e       	mov	r0, r31
     2da:	fc e3       	ldi	r31, 0x3C	; 60
     2dc:	ef 2e       	mov	r14, r31
     2de:	f2 e0       	ldi	r31, 0x02	; 2
     2e0:	ff 2e       	mov	r15, r31
     2e2:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2e4:	0f 2e       	mov	r0, r31
     2e6:	f7 e3       	ldi	r31, 0x37	; 55
     2e8:	cf 2e       	mov	r12, r31
     2ea:	f2 e0       	ldi	r31, 0x02	; 2
     2ec:	df 2e       	mov	r13, r31
     2ee:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     2f0:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2f2:	d7 01       	movw	r26, r14
     2f4:	ed 91       	ld	r30, X+
     2f6:	fc 91       	ld	r31, X
     2f8:	c6 81       	ldd	r28, Z+6	; 0x06
     2fa:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     2fc:	ce 01       	movw	r24, r28
     2fe:	0c 96       	adiw	r24, 0x0c	; 12
     300:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     304:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     306:	8e 01       	movw	r16, r28
     308:	0e 5f       	subi	r16, 0xFE	; 254
     30a:	1f 4f       	sbci	r17, 0xFF	; 255
     30c:	c8 01       	movw	r24, r16
     30e:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     312:	8e 89       	ldd	r24, Y+22	; 0x16
     314:	90 91 12 02 	lds	r25, 0x0212
     318:	98 17       	cp	r25, r24
     31a:	10 f4       	brcc	.+4      	; 0x320 <vCoRoutineSchedule+0x60>
     31c:	80 93 12 02 	sts	0x0212, r24
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	9c 01       	movw	r18, r24
     324:	22 0f       	add	r18, r18
     326:	33 1f       	adc	r19, r19
     328:	22 0f       	add	r18, r18
     32a:	33 1f       	adc	r19, r19
     32c:	22 0f       	add	r18, r18
     32e:	33 1f       	adc	r19, r19
     330:	82 0f       	add	r24, r18
     332:	93 1f       	adc	r25, r19
     334:	8d 5e       	subi	r24, 0xED	; 237
     336:	9d 4f       	sbci	r25, 0xFD	; 253
     338:	b8 01       	movw	r22, r16
     33a:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     33e:	f6 01       	movw	r30, r12
     340:	80 81       	ld	r24, Z
     342:	88 23       	and	r24, r24
     344:	a9 f6       	brne	.-86     	; 0x2f0 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     346:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xTaskGetTickCount>
     34a:	20 91 46 02 	lds	r18, 0x0246
     34e:	30 91 47 02 	lds	r19, 0x0247
     352:	82 1b       	sub	r24, r18
     354:	93 0b       	sbc	r25, r19
     356:	90 93 49 02 	sts	0x0249, r25
     35a:	80 93 48 02 	sts	0x0248, r24
     35e:	74 c0       	rjmp	.+232    	; 0x448 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     360:	20 91 44 02 	lds	r18, 0x0244
     364:	30 91 45 02 	lds	r19, 0x0245
     368:	2f 5f       	subi	r18, 0xFF	; 255
     36a:	3f 4f       	sbci	r19, 0xFF	; 255
     36c:	30 93 45 02 	sts	0x0245, r19
     370:	20 93 44 02 	sts	0x0244, r18
		xPassedTicks--;
     374:	01 97       	sbiw	r24, 0x01	; 1
     376:	90 93 49 02 	sts	0x0249, r25
     37a:	80 93 48 02 	sts	0x0248, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     37e:	21 15       	cp	r18, r1
     380:	31 05       	cpc	r19, r1
     382:	81 f4       	brne	.+32     	; 0x3a4 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     384:	80 91 40 02 	lds	r24, 0x0240
     388:	90 91 41 02 	lds	r25, 0x0241
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     38c:	20 91 42 02 	lds	r18, 0x0242
     390:	30 91 43 02 	lds	r19, 0x0243
     394:	30 93 41 02 	sts	0x0241, r19
     398:	20 93 40 02 	sts	0x0240, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     39c:	90 93 43 02 	sts	0x0243, r25
     3a0:	80 93 42 02 	sts	0x0242, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     3a4:	e0 91 40 02 	lds	r30, 0x0240
     3a8:	f0 91 41 02 	lds	r31, 0x0241
     3ac:	80 81       	ld	r24, Z
     3ae:	88 23       	and	r24, r24
     3b0:	09 f4       	brne	.+2      	; 0x3b4 <vCoRoutineSchedule+0xf4>
     3b2:	4a c0       	rjmp	.+148    	; 0x448 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3b4:	05 80       	ldd	r0, Z+5	; 0x05
     3b6:	f6 81       	ldd	r31, Z+6	; 0x06
     3b8:	e0 2d       	mov	r30, r0
     3ba:	c6 81       	ldd	r28, Z+6	; 0x06
     3bc:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3be:	2a 81       	ldd	r18, Y+2	; 0x02
     3c0:	3b 81       	ldd	r19, Y+3	; 0x03
     3c2:	80 91 44 02 	lds	r24, 0x0244
     3c6:	90 91 45 02 	lds	r25, 0x0245
     3ca:	82 17       	cp	r24, r18
     3cc:	93 07       	cpc	r25, r19
     3ce:	78 f4       	brcc	.+30     	; 0x3ee <vCoRoutineSchedule+0x12e>
     3d0:	3b c0       	rjmp	.+118    	; 0x448 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3d2:	05 80       	ldd	r0, Z+5	; 0x05
     3d4:	f6 81       	ldd	r31, Z+6	; 0x06
     3d6:	e0 2d       	mov	r30, r0
     3d8:	c6 81       	ldd	r28, Z+6	; 0x06
     3da:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3dc:	2a 81       	ldd	r18, Y+2	; 0x02
     3de:	3b 81       	ldd	r19, Y+3	; 0x03
     3e0:	80 91 44 02 	lds	r24, 0x0244
     3e4:	90 91 45 02 	lds	r25, 0x0245
     3e8:	82 17       	cp	r24, r18
     3ea:	93 07       	cpc	r25, r19
     3ec:	68 f1       	brcs	.+90     	; 0x448 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     3ee:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
     3f0:	8e 01       	movw	r16, r28
     3f2:	0e 5f       	subi	r16, 0xFE	; 254
     3f4:	1f 4f       	sbci	r17, 0xFF	; 255
     3f6:	c8 01       	movw	r24, r16
     3f8:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     3fc:	8c 89       	ldd	r24, Y+20	; 0x14
     3fe:	9d 89       	ldd	r25, Y+21	; 0x15
     400:	00 97       	sbiw	r24, 0x00	; 0
     402:	21 f0       	breq	.+8      	; 0x40c <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
     404:	ce 01       	movw	r24, r28
     406:	0c 96       	adiw	r24, 0x0c	; 12
     408:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     40c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     40e:	8e 89       	ldd	r24, Y+22	; 0x16
     410:	90 91 12 02 	lds	r25, 0x0212
     414:	98 17       	cp	r25, r24
     416:	10 f4       	brcc	.+4      	; 0x41c <vCoRoutineSchedule+0x15c>
     418:	80 93 12 02 	sts	0x0212, r24
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	9c 01       	movw	r18, r24
     420:	22 0f       	add	r18, r18
     422:	33 1f       	adc	r19, r19
     424:	22 0f       	add	r18, r18
     426:	33 1f       	adc	r19, r19
     428:	22 0f       	add	r18, r18
     42a:	33 1f       	adc	r19, r19
     42c:	82 0f       	add	r24, r18
     42e:	93 1f       	adc	r25, r19
     430:	8d 5e       	subi	r24, 0xED	; 237
     432:	9d 4f       	sbci	r25, 0xFD	; 253
     434:	b8 01       	movw	r22, r16
     436:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     43a:	e0 91 40 02 	lds	r30, 0x0240
     43e:	f0 91 41 02 	lds	r31, 0x0241
     442:	80 81       	ld	r24, Z
     444:	88 23       	and	r24, r24
     446:	29 f6       	brne	.-118    	; 0x3d2 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     448:	80 91 48 02 	lds	r24, 0x0248
     44c:	90 91 49 02 	lds	r25, 0x0249
     450:	00 97       	sbiw	r24, 0x00	; 0
     452:	09 f0       	breq	.+2      	; 0x456 <vCoRoutineSchedule+0x196>
     454:	85 cf       	rjmp	.-246    	; 0x360 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     456:	80 91 44 02 	lds	r24, 0x0244
     45a:	90 91 45 02 	lds	r25, 0x0245
     45e:	90 93 47 02 	sts	0x0247, r25
     462:	80 93 46 02 	sts	0x0246, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     466:	20 91 12 02 	lds	r18, 0x0212
     46a:	82 2f       	mov	r24, r18
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	fc 01       	movw	r30, r24
     470:	ee 0f       	add	r30, r30
     472:	ff 1f       	adc	r31, r31
     474:	ee 0f       	add	r30, r30
     476:	ff 1f       	adc	r31, r31
     478:	ee 0f       	add	r30, r30
     47a:	ff 1f       	adc	r31, r31
     47c:	e8 0f       	add	r30, r24
     47e:	f9 1f       	adc	r31, r25
     480:	ed 5e       	subi	r30, 0xED	; 237
     482:	fd 4f       	sbci	r31, 0xFD	; 253
     484:	30 81       	ld	r19, Z
     486:	33 23       	and	r19, r19
     488:	d9 f4       	brne	.+54     	; 0x4c0 <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     48a:	22 23       	and	r18, r18
     48c:	31 f4       	brne	.+12     	; 0x49a <vCoRoutineSchedule+0x1da>
     48e:	47 c0       	rjmp	.+142    	; 0x51e <vCoRoutineSchedule+0x25e>
     490:	22 23       	and	r18, r18
     492:	19 f4       	brne	.+6      	; 0x49a <vCoRoutineSchedule+0x1da>
     494:	20 93 12 02 	sts	0x0212, r18
     498:	42 c0       	rjmp	.+132    	; 0x51e <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     49a:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     49c:	82 2f       	mov	r24, r18
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	fc 01       	movw	r30, r24
     4a2:	ee 0f       	add	r30, r30
     4a4:	ff 1f       	adc	r31, r31
     4a6:	ee 0f       	add	r30, r30
     4a8:	ff 1f       	adc	r31, r31
     4aa:	ee 0f       	add	r30, r30
     4ac:	ff 1f       	adc	r31, r31
     4ae:	e8 0f       	add	r30, r24
     4b0:	f9 1f       	adc	r31, r25
     4b2:	ed 5e       	subi	r30, 0xED	; 237
     4b4:	fd 4f       	sbci	r31, 0xFD	; 253
     4b6:	30 81       	ld	r19, Z
     4b8:	33 23       	and	r19, r19
     4ba:	51 f3       	breq	.-44     	; 0x490 <vCoRoutineSchedule+0x1d0>
     4bc:	20 93 12 02 	sts	0x0212, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4c0:	fc 01       	movw	r30, r24
     4c2:	ee 0f       	add	r30, r30
     4c4:	ff 1f       	adc	r31, r31
     4c6:	ee 0f       	add	r30, r30
     4c8:	ff 1f       	adc	r31, r31
     4ca:	ee 0f       	add	r30, r30
     4cc:	ff 1f       	adc	r31, r31
     4ce:	8e 0f       	add	r24, r30
     4d0:	9f 1f       	adc	r25, r31
     4d2:	fc 01       	movw	r30, r24
     4d4:	ed 5e       	subi	r30, 0xED	; 237
     4d6:	fd 4f       	sbci	r31, 0xFD	; 253
     4d8:	a1 81       	ldd	r26, Z+1	; 0x01
     4da:	b2 81       	ldd	r27, Z+2	; 0x02
     4dc:	12 96       	adiw	r26, 0x02	; 2
     4de:	0d 90       	ld	r0, X+
     4e0:	bc 91       	ld	r27, X
     4e2:	a0 2d       	mov	r26, r0
     4e4:	b2 83       	std	Z+2, r27	; 0x02
     4e6:	a1 83       	std	Z+1, r26	; 0x01
     4e8:	cf 01       	movw	r24, r30
     4ea:	03 96       	adiw	r24, 0x03	; 3
     4ec:	a8 17       	cp	r26, r24
     4ee:	b9 07       	cpc	r27, r25
     4f0:	31 f4       	brne	.+12     	; 0x4fe <vCoRoutineSchedule+0x23e>
     4f2:	12 96       	adiw	r26, 0x02	; 2
     4f4:	8d 91       	ld	r24, X+
     4f6:	9c 91       	ld	r25, X
     4f8:	13 97       	sbiw	r26, 0x03	; 3
     4fa:	92 83       	std	Z+2, r25	; 0x02
     4fc:	81 83       	std	Z+1, r24	; 0x01
     4fe:	01 80       	ldd	r0, Z+1	; 0x01
     500:	f2 81       	ldd	r31, Z+2	; 0x02
     502:	e0 2d       	mov	r30, r0
     504:	a6 81       	ldd	r26, Z+6	; 0x06
     506:	b7 81       	ldd	r27, Z+7	; 0x07
     508:	b0 93 11 02 	sts	0x0211, r27
     50c:	a0 93 10 02 	sts	0x0210, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     510:	ed 91       	ld	r30, X+
     512:	fc 91       	ld	r31, X
     514:	11 97       	sbiw	r26, 0x01	; 1
     516:	cd 01       	movw	r24, r26
     518:	57 96       	adiw	r26, 0x17	; 23
     51a:	6c 91       	ld	r22, X
     51c:	19 95       	eicall

	return;
}
     51e:	df 91       	pop	r29
     520:	cf 91       	pop	r28
     522:	1f 91       	pop	r17
     524:	0f 91       	pop	r16
     526:	ff 90       	pop	r15
     528:	ef 90       	pop	r14
     52a:	df 90       	pop	r13
     52c:	cf 90       	pop	r12
     52e:	08 95       	ret

00000530 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     530:	0f 93       	push	r16
     532:	1f 93       	push	r17
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     538:	dc 01       	movw	r26, r24
     53a:	15 96       	adiw	r26, 0x05	; 5
     53c:	ed 91       	ld	r30, X+
     53e:	fc 91       	ld	r31, X
     540:	16 97       	sbiw	r26, 0x06	; 6
     542:	06 81       	ldd	r16, Z+6	; 0x06
     544:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     546:	e8 01       	movw	r28, r16
     548:	2c 96       	adiw	r28, 0x0c	; 12
     54a:	ce 01       	movw	r24, r28
     54c:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     550:	87 e3       	ldi	r24, 0x37	; 55
     552:	92 e0       	ldi	r25, 0x02	; 2
     554:	be 01       	movw	r22, r28
     556:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     55a:	e0 91 10 02 	lds	r30, 0x0210
     55e:	f0 91 11 02 	lds	r31, 0x0211
	{
		xReturn = pdTRUE;
     562:	81 e0       	ldi	r24, 0x01	; 1
     564:	d8 01       	movw	r26, r16
     566:	56 96       	adiw	r26, 0x16	; 22
     568:	2c 91       	ld	r18, X
     56a:	56 97       	sbiw	r26, 0x16	; 22
     56c:	96 89       	ldd	r25, Z+22	; 0x16
     56e:	29 17       	cp	r18, r25
     570:	08 f4       	brcc	.+2      	; 0x574 <xCoRoutineRemoveFromEventList+0x44>
     572:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	1f 91       	pop	r17
     57a:	0f 91       	pop	r16
     57c:	08 95       	ret

0000057e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     57e:	0f 93       	push	r16
     580:	1f 93       	push	r17
     582:	cf 93       	push	r28
     584:	df 93       	push	r29
     586:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     588:	0e 94 24 0c 	call	0x1848	; 0x1848 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     58c:	00 91 4a 02 	lds	r16, 0x024A
     590:	10 91 4b 02 	lds	r17, 0x024B
     594:	c0 0f       	add	r28, r16
     596:	d1 1f       	adc	r29, r17
     598:	88 e1       	ldi	r24, 0x18	; 24
     59a:	c0 30       	cpi	r28, 0x00	; 0
     59c:	d8 07       	cpc	r29, r24
     59e:	50 f4       	brcc	.+20     	; 0x5b4 <pvPortMalloc+0x36>
     5a0:	0c 17       	cp	r16, r28
     5a2:	1d 07       	cpc	r17, r29
     5a4:	50 f4       	brcc	.+20     	; 0x5ba <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     5a6:	04 5b       	subi	r16, 0xB4	; 180
     5a8:	1d 4f       	sbci	r17, 0xFD	; 253
			xNextFreeByte += xWantedSize;
     5aa:	d0 93 4b 02 	sts	0x024B, r29
     5ae:	c0 93 4a 02 	sts	0x024A, r28
     5b2:	05 c0       	rjmp	.+10     	; 0x5be <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5b4:	00 e0       	ldi	r16, 0x00	; 0
     5b6:	10 e0       	ldi	r17, 0x00	; 0
     5b8:	02 c0       	rjmp	.+4      	; 0x5be <pvPortMalloc+0x40>
     5ba:	00 e0       	ldi	r16, 0x00	; 0
     5bc:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
     5be:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5c2:	80 2f       	mov	r24, r16
     5c4:	91 2f       	mov	r25, r17
     5c6:	df 91       	pop	r29
     5c8:	cf 91       	pop	r28
     5ca:	1f 91       	pop	r17
     5cc:	0f 91       	pop	r16
     5ce:	08 95       	ret

000005d0 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     5d0:	08 95       	ret

000005d2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     5d2:	10 92 4b 02 	sts	0x024B, r1
     5d6:	10 92 4a 02 	sts	0x024A, r1
}
     5da:	08 95       	ret

000005dc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     5dc:	20 91 4a 02 	lds	r18, 0x024A
     5e0:	30 91 4b 02 	lds	r19, 0x024B
     5e4:	80 e0       	ldi	r24, 0x00	; 0
     5e6:	98 e1       	ldi	r25, 0x18	; 24
     5e8:	82 1b       	sub	r24, r18
     5ea:	93 0b       	sbc	r25, r19
}
     5ec:	08 95       	ret

000005ee <vTaskFunction_timerHandler>:
*		   the task to run at a desired frequency.
*
* return: void
*--------------------------------------------------------*/
void vTaskFunction_timerHandler(void *pvNada)
{
     5ee:	cf 93       	push	r28
     5f0:	df 93       	push	r29
     5f2:	0f 92       	push	r0
     5f4:	0f 92       	push	r0
     5f6:	cd b7       	in	r28, 0x3d	; 61
     5f8:	de b7       	in	r29, 0x3e	; 62
	static uint8_t task_cnt = 0, sseg_cnt_L = 0, sseg_cnt_R = 0;

	portTickType xLastExecutionTime;
	xLastExecutionTime = xTaskGetTickCount();
     5fa:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xTaskGetTickCount>
     5fe:	9a 83       	std	Y+2, r25	; 0x02
     600:	89 83       	std	Y+1, r24	; 0x01
		xSemaphoreTake( xMutex, portMAX_DELAY );	
		SSEG_Write_left_digits(sseg_cnt_L);
		SSEG_Write_right_digits(sseg_cnt_R);
		xSemaphoreGive( xMutex );
		
		task_cnt ^= 1;
     602:	11 e0       	ldi	r17, 0x01	; 1
				sseg_cnt_L = 0;
			else
				sseg_cnt_L++;
		}		
		
		PORTA ^= (1 << LED2);//Toggle LED2
     604:	04 e0       	ldi	r16, 0x04	; 4

	portTickType xLastExecutionTime;
	xLastExecutionTime = xTaskGetTickCount();
	for(;;)
	{
		xSemaphoreTake( xMutex, portMAX_DELAY );	
     606:	80 91 ab 1a 	lds	r24, 0x1AAB
     60a:	90 91 ac 1a 	lds	r25, 0x1AAC
     60e:	60 e0       	ldi	r22, 0x00	; 0
     610:	70 e0       	ldi	r23, 0x00	; 0
     612:	4f ef       	ldi	r20, 0xFF	; 255
     614:	5f ef       	ldi	r21, 0xFF	; 255
     616:	20 e0       	ldi	r18, 0x00	; 0
     618:	0e 94 4a 08 	call	0x1094	; 0x1094 <xQueueGenericReceive>
		SSEG_Write_left_digits(sseg_cnt_L);
     61c:	80 91 4c 1a 	lds	r24, 0x1A4C
     620:	0e 94 c6 09 	call	0x138c	; 0x138c <SSEG_Write_left_digits>
		SSEG_Write_right_digits(sseg_cnt_R);
     624:	80 91 4d 1a 	lds	r24, 0x1A4D
     628:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <SSEG_Write_right_digits>
		xSemaphoreGive( xMutex );
     62c:	80 91 ab 1a 	lds	r24, 0x1AAB
     630:	90 91 ac 1a 	lds	r25, 0x1AAC
     634:	60 e0       	ldi	r22, 0x00	; 0
     636:	70 e0       	ldi	r23, 0x00	; 0
     638:	40 e0       	ldi	r20, 0x00	; 0
     63a:	50 e0       	ldi	r21, 0x00	; 0
     63c:	20 e0       	ldi	r18, 0x00	; 0
     63e:	0e 94 4d 07 	call	0xe9a	; 0xe9a <xQueueGenericSend>
		
		task_cnt ^= 1;
     642:	80 91 4e 1a 	lds	r24, 0x1A4E
     646:	81 27       	eor	r24, r17
     648:	80 93 4e 1a 	sts	0x1A4E, r24
		if(task_cnt)
     64c:	88 23       	and	r24, r24
     64e:	69 f0       	breq	.+26     	; 0x66a <vTaskFunction_timerHandler+0x7c>
		{
			PORTA ^= (1 << LED0);//Toggle LED0
     650:	82 b1       	in	r24, 0x02	; 2
     652:	81 27       	eor	r24, r17
     654:	82 b9       	out	0x02, r24	; 2
			if (sseg_cnt_L == MAX_COUNT)
     656:	80 91 4c 1a 	lds	r24, 0x1A4C
     65a:	83 36       	cpi	r24, 0x63	; 99
     65c:	19 f4       	brne	.+6      	; 0x664 <vTaskFunction_timerHandler+0x76>
				sseg_cnt_L = 0;
     65e:	10 92 4c 1a 	sts	0x1A4C, r1
     662:	03 c0       	rjmp	.+6      	; 0x66a <vTaskFunction_timerHandler+0x7c>
			else
				sseg_cnt_L++;
     664:	8f 5f       	subi	r24, 0xFF	; 255
     666:	80 93 4c 1a 	sts	0x1A4C, r24
		}		
		
		PORTA ^= (1 << LED2);//Toggle LED2
     66a:	82 b1       	in	r24, 0x02	; 2
     66c:	80 27       	eor	r24, r16
     66e:	82 b9       	out	0x02, r24	; 2
		if (sseg_cnt_R == MAX_COUNT)
     670:	80 91 4d 1a 	lds	r24, 0x1A4D
     674:	83 36       	cpi	r24, 0x63	; 99
     676:	19 f4       	brne	.+6      	; 0x67e <vTaskFunction_timerHandler+0x90>
			sseg_cnt_R = 0;
     678:	10 92 4d 1a 	sts	0x1A4D, r1
     67c:	03 c0       	rjmp	.+6      	; 0x684 <vTaskFunction_timerHandler+0x96>
		else
			sseg_cnt_R++;
     67e:	8f 5f       	subi	r24, 0xFF	; 255
     680:	80 93 4d 1a 	sts	0x1A4D, r24
		
		vTaskDelayUntil(&xLastExecutionTime, DELAY_MS_10HZ/portTICK_RATE_MS);
     684:	ce 01       	movw	r24, r28
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	62 e3       	ldi	r22, 0x32	; 50
     68a:	70 e0       	ldi	r23, 0x00	; 0
     68c:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <vTaskDelayUntil>
	}
     690:	ba cf       	rjmp	.-140    	; 0x606 <vTaskFunction_timerHandler+0x18>

00000692 <main>:
//---------------------Globals---------------------------//
xSemaphoreHandle xMutex;

//-------------------Main Function-----------------------//
int main( void )
{  	
     692:	af 92       	push	r10
     694:	bf 92       	push	r11
     696:	cf 92       	push	r12
     698:	df 92       	push	r13
     69a:	ef 92       	push	r14
     69c:	ff 92       	push	r15
     69e:	0f 93       	push	r16
    // Function initializing PORTA as an output and setting LEDs low
	vIO_init(); 
     6a0:	0e 94 96 00 	call	0x12c	; 0x12c <vIO_init>
	SPI_MasterInit(); 
     6a4:	0e 94 7d 09 	call	0x12fa	; 0x12fa <SPI_MasterInit>
	
	//create mutex for data protection when writing to 7-seg
	xMutex = xSemaphoreCreateMutex();
     6a8:	81 e0       	ldi	r24, 0x01	; 1
     6aa:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <xQueueCreateMutex>
     6ae:	90 93 ac 1a 	sts	0x1AAC, r25
     6b2:	80 93 ab 1a 	sts	0x1AAB, r24
	
	// Creates a handler task for the interrupt generated by Timer2 CTC
	xTaskCreate(vTaskFunction_timerHandler, "TMR Task", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     6b6:	87 ef       	ldi	r24, 0xF7	; 247
     6b8:	92 e0       	ldi	r25, 0x02	; 2
     6ba:	60 e0       	ldi	r22, 0x00	; 0
     6bc:	72 e0       	ldi	r23, 0x02	; 2
     6be:	45 e5       	ldi	r20, 0x55	; 85
     6c0:	50 e0       	ldi	r21, 0x00	; 0
     6c2:	20 e0       	ldi	r18, 0x00	; 0
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	01 e0       	ldi	r16, 0x01	; 1
     6c8:	ee 24       	eor	r14, r14
     6ca:	ff 24       	eor	r15, r15
     6cc:	cc 24       	eor	r12, r12
     6ce:	dd 24       	eor	r13, r13
     6d0:	aa 24       	eor	r10, r10
     6d2:	bb 24       	eor	r11, r11
     6d4:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskGenericCreate>
	
    // Start the task scheduler
	vTaskStartScheduler();
     6d8:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <vTaskStartScheduler>

	return 0;
}
     6dc:	80 e0       	ldi	r24, 0x00	; 0
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	0f 91       	pop	r16
     6e2:	ff 90       	pop	r15
     6e4:	ef 90       	pop	r14
     6e6:	df 90       	pop	r13
     6e8:	cf 90       	pop	r12
     6ea:	bf 90       	pop	r11
     6ec:	af 90       	pop	r10
     6ee:	08 95       	ret

000006f0 <vApplicationTickHook>:
void vApplicationTickHook( void )
{
	static uint16_t count = 0;
	
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
     6f0:	10 92 4f 1a 	sts	0x1A4F, r1
		
	count++;
     6f4:	80 91 50 1a 	lds	r24, 0x1A50
     6f8:	90 91 51 1a 	lds	r25, 0x1A51
     6fc:	01 96       	adiw	r24, 0x01	; 1
     6fe:	90 93 51 1a 	sts	0x1A51, r25
     702:	80 93 50 1a 	sts	0x1A50, r24
	
	if(count == 500) //turns off the colon at half the period
     706:	21 e0       	ldi	r18, 0x01	; 1
     708:	84 3f       	cpi	r24, 0xF4	; 244
     70a:	92 07       	cpc	r25, r18
     70c:	01 f5       	brne	.+64     	; 0x74e <vApplicationTickHook+0x5e>
	{
		xSemaphoreTake(xMutex, portMAX_DELAY);
     70e:	80 91 ab 1a 	lds	r24, 0x1AAB
     712:	90 91 ac 1a 	lds	r25, 0x1AAC
     716:	60 e0       	ldi	r22, 0x00	; 0
     718:	70 e0       	ldi	r23, 0x00	; 0
     71a:	4f ef       	ldi	r20, 0xFF	; 255
     71c:	5f ef       	ldi	r21, 0xFF	; 255
     71e:	20 e0       	ldi	r18, 0x00	; 0
     720:	0e 94 4a 08 	call	0x1094	; 0x1094 <xQueueGenericReceive>
		SSEG_Write_Decimal_Point(0x00);
     724:	80 e0       	ldi	r24, 0x00	; 0
     726:	0e 94 ef 09 	call	0x13de	; 0x13de <SSEG_Write_Decimal_Point>
		xSemaphoreGiveFromISR(xMutex, &xHigherPriorityTaskWoken);
     72a:	80 91 ab 1a 	lds	r24, 0x1AAB
     72e:	90 91 ac 1a 	lds	r25, 0x1AAC
     732:	60 e0       	ldi	r22, 0x00	; 0
     734:	70 e0       	ldi	r23, 0x00	; 0
     736:	4f e4       	ldi	r20, 0x4F	; 79
     738:	5a e1       	ldi	r21, 0x1A	; 26
     73a:	20 e0       	ldi	r18, 0x00	; 0
     73c:	0e 94 18 08 	call	0x1030	; 0x1030 <xQueueGenericSendFromISR>
		
		// perform context switch if handler is of higher priority
		if( xHigherPriorityTaskWoken == pdTRUE )
     740:	80 91 4f 1a 	lds	r24, 0x1A4F
     744:	81 30       	cpi	r24, 0x01	; 1
     746:	51 f5       	brne	.+84     	; 0x79c <vApplicationTickHook+0xac>
		{
			vPortYield();
     748:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
     74c:	08 95       	ret
		}
	}
	else if(count == 1000) //turns on the colon at the period
     74e:	23 e0       	ldi	r18, 0x03	; 3
     750:	88 3e       	cpi	r24, 0xE8	; 232
     752:	92 07       	cpc	r25, r18
     754:	19 f5       	brne	.+70     	; 0x79c <vApplicationTickHook+0xac>
	{
		count = 0;
     756:	10 92 51 1a 	sts	0x1A51, r1
     75a:	10 92 50 1a 	sts	0x1A50, r1
		
		xSemaphoreTake(xMutex, portMAX_DELAY);
     75e:	80 91 ab 1a 	lds	r24, 0x1AAB
     762:	90 91 ac 1a 	lds	r25, 0x1AAC
     766:	60 e0       	ldi	r22, 0x00	; 0
     768:	70 e0       	ldi	r23, 0x00	; 0
     76a:	4f ef       	ldi	r20, 0xFF	; 255
     76c:	5f ef       	ldi	r21, 0xFF	; 255
     76e:	20 e0       	ldi	r18, 0x00	; 0
     770:	0e 94 4a 08 	call	0x1094	; 0x1094 <xQueueGenericReceive>
		SSEG_Write_Decimal_Point(SSEG_DP_4);
     774:	80 e1       	ldi	r24, 0x10	; 16
     776:	0e 94 ef 09 	call	0x13de	; 0x13de <SSEG_Write_Decimal_Point>
		xSemaphoreGiveFromISR(xMutex, &xHigherPriorityTaskWoken);
     77a:	80 91 ab 1a 	lds	r24, 0x1AAB
     77e:	90 91 ac 1a 	lds	r25, 0x1AAC
     782:	60 e0       	ldi	r22, 0x00	; 0
     784:	70 e0       	ldi	r23, 0x00	; 0
     786:	4f e4       	ldi	r20, 0x4F	; 79
     788:	5a e1       	ldi	r21, 0x1A	; 26
     78a:	20 e0       	ldi	r18, 0x00	; 0
     78c:	0e 94 18 08 	call	0x1030	; 0x1030 <xQueueGenericSendFromISR>
		
		// perform context switch if handler is of higher priority
		if( xHigherPriorityTaskWoken == pdTRUE )
     790:	80 91 4f 1a 	lds	r24, 0x1A4F
     794:	81 30       	cpi	r24, 0x01	; 1
     796:	11 f4       	brne	.+4      	; 0x79c <vApplicationTickHook+0xac>
		{
			vPortYield();
     798:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
     79c:	08 95       	ret

0000079e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     79e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     7a0:	03 96       	adiw	r24, 0x03	; 3
     7a2:	92 83       	std	Z+2, r25	; 0x02
     7a4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     7a6:	2f ef       	ldi	r18, 0xFF	; 255
     7a8:	3f ef       	ldi	r19, 0xFF	; 255
     7aa:	34 83       	std	Z+4, r19	; 0x04
     7ac:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     7ae:	96 83       	std	Z+6, r25	; 0x06
     7b0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     7b2:	90 87       	std	Z+8, r25	; 0x08
     7b4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     7b6:	10 82       	st	Z, r1
}
     7b8:	08 95       	ret

000007ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     7ba:	fc 01       	movw	r30, r24
     7bc:	11 86       	std	Z+9, r1	; 0x09
     7be:	10 86       	std	Z+8, r1	; 0x08
}
     7c0:	08 95       	ret

000007c2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     7c2:	cf 93       	push	r28
     7c4:	df 93       	push	r29
     7c6:	ec 01       	movw	r28, r24
     7c8:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     7ca:	89 81       	ldd	r24, Y+1	; 0x01
     7cc:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     7ce:	dc 01       	movw	r26, r24
     7d0:	12 96       	adiw	r26, 0x02	; 2
     7d2:	2d 91       	ld	r18, X+
     7d4:	3c 91       	ld	r19, X
     7d6:	13 97       	sbiw	r26, 0x03	; 3
     7d8:	33 83       	std	Z+3, r19	; 0x03
     7da:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     7dc:	29 81       	ldd	r18, Y+1	; 0x01
     7de:	3a 81       	ldd	r19, Y+2	; 0x02
     7e0:	35 83       	std	Z+5, r19	; 0x05
     7e2:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     7e4:	12 96       	adiw	r26, 0x02	; 2
     7e6:	2d 91       	ld	r18, X+
     7e8:	3c 91       	ld	r19, X
     7ea:	13 97       	sbiw	r26, 0x03	; 3
     7ec:	d9 01       	movw	r26, r18
     7ee:	15 96       	adiw	r26, 0x05	; 5
     7f0:	7c 93       	st	X, r23
     7f2:	6e 93       	st	-X, r22
     7f4:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     7f6:	dc 01       	movw	r26, r24
     7f8:	13 96       	adiw	r26, 0x03	; 3
     7fa:	7c 93       	st	X, r23
     7fc:	6e 93       	st	-X, r22
     7fe:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     800:	7a 83       	std	Y+2, r23	; 0x02
     802:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     804:	d1 87       	std	Z+9, r29	; 0x09
     806:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     808:	88 81       	ld	r24, Y
     80a:	8f 5f       	subi	r24, 0xFF	; 255
     80c:	88 83       	st	Y, r24
}
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	08 95       	ret

00000814 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     814:	cf 93       	push	r28
     816:	df 93       	push	r29
     818:	ac 01       	movw	r20, r24
     81a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     81c:	28 81       	ld	r18, Y
     81e:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     820:	8f ef       	ldi	r24, 0xFF	; 255
     822:	2f 3f       	cpi	r18, 0xFF	; 255
     824:	38 07       	cpc	r19, r24
     826:	21 f4       	brne	.+8      	; 0x830 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     828:	fa 01       	movw	r30, r20
     82a:	a7 81       	ldd	r26, Z+7	; 0x07
     82c:	b0 85       	ldd	r27, Z+8	; 0x08
     82e:	18 c0       	rjmp	.+48     	; 0x860 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     830:	da 01       	movw	r26, r20
     832:	13 96       	adiw	r26, 0x03	; 3
     834:	fa 01       	movw	r30, r20
     836:	85 81       	ldd	r24, Z+5	; 0x05
     838:	96 81       	ldd	r25, Z+6	; 0x06
     83a:	fc 01       	movw	r30, r24
     83c:	80 81       	ld	r24, Z
     83e:	91 81       	ldd	r25, Z+1	; 0x01
     840:	28 17       	cp	r18, r24
     842:	39 07       	cpc	r19, r25
     844:	68 f0       	brcs	.+26     	; 0x860 <vListInsert+0x4c>
     846:	12 96       	adiw	r26, 0x02	; 2
     848:	0d 90       	ld	r0, X+
     84a:	bc 91       	ld	r27, X
     84c:	a0 2d       	mov	r26, r0
     84e:	12 96       	adiw	r26, 0x02	; 2
     850:	ed 91       	ld	r30, X+
     852:	fc 91       	ld	r31, X
     854:	13 97       	sbiw	r26, 0x03	; 3
     856:	80 81       	ld	r24, Z
     858:	91 81       	ldd	r25, Z+1	; 0x01
     85a:	28 17       	cp	r18, r24
     85c:	39 07       	cpc	r19, r25
     85e:	98 f7       	brcc	.-26     	; 0x846 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     860:	12 96       	adiw	r26, 0x02	; 2
     862:	ed 91       	ld	r30, X+
     864:	fc 91       	ld	r31, X
     866:	13 97       	sbiw	r26, 0x03	; 3
     868:	fb 83       	std	Y+3, r31	; 0x03
     86a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     86c:	d5 83       	std	Z+5, r29	; 0x05
     86e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     870:	bd 83       	std	Y+5, r27	; 0x05
     872:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     874:	13 96       	adiw	r26, 0x03	; 3
     876:	dc 93       	st	X, r29
     878:	ce 93       	st	-X, r28
     87a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     87c:	59 87       	std	Y+9, r21	; 0x09
     87e:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     880:	fa 01       	movw	r30, r20
     882:	80 81       	ld	r24, Z
     884:	8f 5f       	subi	r24, 0xFF	; 255
     886:	80 83       	st	Z, r24
}
     888:	df 91       	pop	r29
     88a:	cf 91       	pop	r28
     88c:	08 95       	ret

0000088e <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
     88e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     890:	a2 81       	ldd	r26, Z+2	; 0x02
     892:	b3 81       	ldd	r27, Z+3	; 0x03
     894:	84 81       	ldd	r24, Z+4	; 0x04
     896:	95 81       	ldd	r25, Z+5	; 0x05
     898:	15 96       	adiw	r26, 0x05	; 5
     89a:	9c 93       	st	X, r25
     89c:	8e 93       	st	-X, r24
     89e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8a0:	a4 81       	ldd	r26, Z+4	; 0x04
     8a2:	b5 81       	ldd	r27, Z+5	; 0x05
     8a4:	82 81       	ldd	r24, Z+2	; 0x02
     8a6:	93 81       	ldd	r25, Z+3	; 0x03
     8a8:	13 96       	adiw	r26, 0x03	; 3
     8aa:	9c 93       	st	X, r25
     8ac:	8e 93       	st	-X, r24
     8ae:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     8b0:	a0 85       	ldd	r26, Z+8	; 0x08
     8b2:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8b4:	11 96       	adiw	r26, 0x01	; 1
     8b6:	8d 91       	ld	r24, X+
     8b8:	9c 91       	ld	r25, X
     8ba:	12 97       	sbiw	r26, 0x02	; 2
     8bc:	8e 17       	cp	r24, r30
     8be:	9f 07       	cpc	r25, r31
     8c0:	31 f4       	brne	.+12     	; 0x8ce <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     8c2:	84 81       	ldd	r24, Z+4	; 0x04
     8c4:	95 81       	ldd	r25, Z+5	; 0x05
     8c6:	12 96       	adiw	r26, 0x02	; 2
     8c8:	9c 93       	st	X, r25
     8ca:	8e 93       	st	-X, r24
     8cc:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     8ce:	11 86       	std	Z+9, r1	; 0x09
     8d0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     8d2:	8c 91       	ld	r24, X
     8d4:	81 50       	subi	r24, 0x01	; 1
     8d6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     8d8:	8c 91       	ld	r24, X
}
     8da:	08 95       	ret

000008dc <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     8dc:	21 e1       	ldi	r18, 0x11	; 17
     8de:	fc 01       	movw	r30, r24
     8e0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     8e2:	31 97       	sbiw	r30, 0x01	; 1
     8e4:	32 e2       	ldi	r19, 0x22	; 34
     8e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     8e8:	fc 01       	movw	r30, r24
     8ea:	32 97       	sbiw	r30, 0x02	; 2
     8ec:	a3 e3       	ldi	r26, 0x33	; 51
     8ee:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     8f0:	fc 01       	movw	r30, r24
     8f2:	33 97       	sbiw	r30, 0x03	; 3
     8f4:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     8f6:	fc 01       	movw	r30, r24
     8f8:	34 97       	sbiw	r30, 0x04	; 4
     8fa:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
     8fc:	fc 01       	movw	r30, r24
     8fe:	35 97       	sbiw	r30, 0x05	; 5
     900:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     902:	fc 01       	movw	r30, r24
     904:	36 97       	sbiw	r30, 0x06	; 6
     906:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     908:	fc 01       	movw	r30, r24
     90a:	37 97       	sbiw	r30, 0x07	; 7
     90c:	60 e8       	ldi	r22, 0x80	; 128
     90e:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
     910:	fc 01       	movw	r30, r24
     912:	38 97       	sbiw	r30, 0x08	; 8
     914:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
     916:	fc 01       	movw	r30, r24
     918:	39 97       	sbiw	r30, 0x09	; 9
     91a:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     91c:	fc 01       	movw	r30, r24
     91e:	3a 97       	sbiw	r30, 0x0a	; 10
     920:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     922:	fc 01       	movw	r30, r24
     924:	3b 97       	sbiw	r30, 0x0b	; 11
     926:	62 e0       	ldi	r22, 0x02	; 2
     928:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     92a:	fc 01       	movw	r30, r24
     92c:	3c 97       	sbiw	r30, 0x0c	; 12
     92e:	63 e0       	ldi	r22, 0x03	; 3
     930:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     932:	fc 01       	movw	r30, r24
     934:	3d 97       	sbiw	r30, 0x0d	; 13
     936:	64 e0       	ldi	r22, 0x04	; 4
     938:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     93a:	fc 01       	movw	r30, r24
     93c:	3e 97       	sbiw	r30, 0x0e	; 14
     93e:	65 e0       	ldi	r22, 0x05	; 5
     940:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     942:	fc 01       	movw	r30, r24
     944:	3f 97       	sbiw	r30, 0x0f	; 15
     946:	66 e0       	ldi	r22, 0x06	; 6
     948:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     94a:	fc 01       	movw	r30, r24
     94c:	70 97       	sbiw	r30, 0x10	; 16
     94e:	67 e0       	ldi	r22, 0x07	; 7
     950:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     952:	fc 01       	movw	r30, r24
     954:	71 97       	sbiw	r30, 0x11	; 17
     956:	68 e0       	ldi	r22, 0x08	; 8
     958:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     95a:	fc 01       	movw	r30, r24
     95c:	72 97       	sbiw	r30, 0x12	; 18
     95e:	69 e0       	ldi	r22, 0x09	; 9
     960:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     962:	fc 01       	movw	r30, r24
     964:	73 97       	sbiw	r30, 0x13	; 19
     966:	60 e1       	ldi	r22, 0x10	; 16
     968:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     96a:	fc 01       	movw	r30, r24
     96c:	74 97       	sbiw	r30, 0x14	; 20
     96e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     970:	fc 01       	movw	r30, r24
     972:	75 97       	sbiw	r30, 0x15	; 21
     974:	22 e1       	ldi	r18, 0x12	; 18
     976:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     978:	fc 01       	movw	r30, r24
     97a:	76 97       	sbiw	r30, 0x16	; 22
     97c:	23 e1       	ldi	r18, 0x13	; 19
     97e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     980:	fc 01       	movw	r30, r24
     982:	77 97       	sbiw	r30, 0x17	; 23
     984:	24 e1       	ldi	r18, 0x14	; 20
     986:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     988:	fc 01       	movw	r30, r24
     98a:	78 97       	sbiw	r30, 0x18	; 24
     98c:	25 e1       	ldi	r18, 0x15	; 21
     98e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     990:	fc 01       	movw	r30, r24
     992:	79 97       	sbiw	r30, 0x19	; 25
     994:	26 e1       	ldi	r18, 0x16	; 22
     996:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     998:	fc 01       	movw	r30, r24
     99a:	7a 97       	sbiw	r30, 0x1a	; 26
     99c:	27 e1       	ldi	r18, 0x17	; 23
     99e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     9a0:	fc 01       	movw	r30, r24
     9a2:	7b 97       	sbiw	r30, 0x1b	; 27
     9a4:	28 e1       	ldi	r18, 0x18	; 24
     9a6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     9a8:	fc 01       	movw	r30, r24
     9aa:	7c 97       	sbiw	r30, 0x1c	; 28
     9ac:	29 e1       	ldi	r18, 0x19	; 25
     9ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     9b0:	fc 01       	movw	r30, r24
     9b2:	7d 97       	sbiw	r30, 0x1d	; 29
     9b4:	20 e2       	ldi	r18, 0x20	; 32
     9b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     9b8:	fc 01       	movw	r30, r24
     9ba:	7e 97       	sbiw	r30, 0x1e	; 30
     9bc:	21 e2       	ldi	r18, 0x21	; 33
     9be:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     9c0:	fc 01       	movw	r30, r24
     9c2:	7f 97       	sbiw	r30, 0x1f	; 31
     9c4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     9c6:	fc 01       	movw	r30, r24
     9c8:	b0 97       	sbiw	r30, 0x20	; 32
     9ca:	23 e2       	ldi	r18, 0x23	; 35
     9cc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     9ce:	fc 01       	movw	r30, r24
     9d0:	b1 97       	sbiw	r30, 0x21	; 33
     9d2:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     9d4:	fc 01       	movw	r30, r24
     9d6:	b2 97       	sbiw	r30, 0x22	; 34
     9d8:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     9da:	fc 01       	movw	r30, r24
     9dc:	b3 97       	sbiw	r30, 0x23	; 35
     9de:	26 e2       	ldi	r18, 0x26	; 38
     9e0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     9e2:	fc 01       	movw	r30, r24
     9e4:	b4 97       	sbiw	r30, 0x24	; 36
     9e6:	27 e2       	ldi	r18, 0x27	; 39
     9e8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     9ea:	fc 01       	movw	r30, r24
     9ec:	b5 97       	sbiw	r30, 0x25	; 37
     9ee:	28 e2       	ldi	r18, 0x28	; 40
     9f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     9f2:	fc 01       	movw	r30, r24
     9f4:	b6 97       	sbiw	r30, 0x26	; 38
     9f6:	29 e2       	ldi	r18, 0x29	; 41
     9f8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     9fa:	fc 01       	movw	r30, r24
     9fc:	b7 97       	sbiw	r30, 0x27	; 39
     9fe:	20 e3       	ldi	r18, 0x30	; 48
     a00:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     a02:	fc 01       	movw	r30, r24
     a04:	b8 97       	sbiw	r30, 0x28	; 40
     a06:	21 e3       	ldi	r18, 0x31	; 49
     a08:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     a0a:	89 97       	sbiw	r24, 0x29	; 41
}
     a0c:	08 95       	ret

00000a0e <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
     a0e:	10 92 99 00 	sts	0x0099, r1

#endif

    portOCRL = ucLowByte;
     a12:	89 ef       	ldi	r24, 0xF9	; 249
     a14:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
     a18:	8b e0       	ldi	r24, 0x0B	; 11
     a1a:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
     a1e:	e1 e7       	ldi	r30, 0x71	; 113
     a20:	f0 e0       	ldi	r31, 0x00	; 0
     a22:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     a24:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
     a26:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     a28:	a0 91 52 1a 	lds	r26, 0x1A52
     a2c:	b0 91 53 1a 	lds	r27, 0x1A53
     a30:	cd 91       	ld	r28, X+
     a32:	cd bf       	out	0x3d, r28	; 61
     a34:	dd 91       	ld	r29, X+
     a36:	de bf       	out	0x3e, r29	; 62
     a38:	ff 91       	pop	r31
     a3a:	ef 91       	pop	r30
     a3c:	df 91       	pop	r29
     a3e:	cf 91       	pop	r28
     a40:	bf 91       	pop	r27
     a42:	af 91       	pop	r26
     a44:	9f 91       	pop	r25
     a46:	8f 91       	pop	r24
     a48:	7f 91       	pop	r23
     a4a:	6f 91       	pop	r22
     a4c:	5f 91       	pop	r21
     a4e:	4f 91       	pop	r20
     a50:	3f 91       	pop	r19
     a52:	2f 91       	pop	r18
     a54:	1f 91       	pop	r17
     a56:	0f 91       	pop	r16
     a58:	ff 90       	pop	r15
     a5a:	ef 90       	pop	r14
     a5c:	df 90       	pop	r13
     a5e:	cf 90       	pop	r12
     a60:	bf 90       	pop	r11
     a62:	af 90       	pop	r10
     a64:	9f 90       	pop	r9
     a66:	8f 90       	pop	r8
     a68:	7f 90       	pop	r7
     a6a:	6f 90       	pop	r6
     a6c:	5f 90       	pop	r5
     a6e:	4f 90       	pop	r4
     a70:	3f 90       	pop	r3
     a72:	2f 90       	pop	r2
     a74:	1f 90       	pop	r1
     a76:	0f 90       	pop	r0
     a78:	0c be       	out	0x3c, r0	; 60
     a7a:	0f 90       	pop	r0
     a7c:	0b be       	out	0x3b, r0	; 59
     a7e:	0f 90       	pop	r0
     a80:	0f be       	out	0x3f, r0	; 63
     a82:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     a84:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     a86:	81 e0       	ldi	r24, 0x01	; 1
     a88:	08 95       	ret

00000a8a <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     a8a:	08 95       	ret

00000a8c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a8c:	0f 92       	push	r0
     a8e:	0f b6       	in	r0, 0x3f	; 63
     a90:	f8 94       	cli
     a92:	0f 92       	push	r0
     a94:	0b b6       	in	r0, 0x3b	; 59
     a96:	0f 92       	push	r0
     a98:	0c b6       	in	r0, 0x3c	; 60
     a9a:	0f 92       	push	r0
     a9c:	1f 92       	push	r1
     a9e:	11 24       	eor	r1, r1
     aa0:	2f 92       	push	r2
     aa2:	3f 92       	push	r3
     aa4:	4f 92       	push	r4
     aa6:	5f 92       	push	r5
     aa8:	6f 92       	push	r6
     aaa:	7f 92       	push	r7
     aac:	8f 92       	push	r8
     aae:	9f 92       	push	r9
     ab0:	af 92       	push	r10
     ab2:	bf 92       	push	r11
     ab4:	cf 92       	push	r12
     ab6:	df 92       	push	r13
     ab8:	ef 92       	push	r14
     aba:	ff 92       	push	r15
     abc:	0f 93       	push	r16
     abe:	1f 93       	push	r17
     ac0:	2f 93       	push	r18
     ac2:	3f 93       	push	r19
     ac4:	4f 93       	push	r20
     ac6:	5f 93       	push	r21
     ac8:	6f 93       	push	r22
     aca:	7f 93       	push	r23
     acc:	8f 93       	push	r24
     ace:	9f 93       	push	r25
     ad0:	af 93       	push	r26
     ad2:	bf 93       	push	r27
     ad4:	cf 93       	push	r28
     ad6:	df 93       	push	r29
     ad8:	ef 93       	push	r30
     ada:	ff 93       	push	r31
     adc:	a0 91 52 1a 	lds	r26, 0x1A52
     ae0:	b0 91 53 1a 	lds	r27, 0x1A53
     ae4:	0d b6       	in	r0, 0x3d	; 61
     ae6:	0d 92       	st	X+, r0
     ae8:	0e b6       	in	r0, 0x3e	; 62
     aea:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     aec:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     af0:	a0 91 52 1a 	lds	r26, 0x1A52
     af4:	b0 91 53 1a 	lds	r27, 0x1A53
     af8:	cd 91       	ld	r28, X+
     afa:	cd bf       	out	0x3d, r28	; 61
     afc:	dd 91       	ld	r29, X+
     afe:	de bf       	out	0x3e, r29	; 62
     b00:	ff 91       	pop	r31
     b02:	ef 91       	pop	r30
     b04:	df 91       	pop	r29
     b06:	cf 91       	pop	r28
     b08:	bf 91       	pop	r27
     b0a:	af 91       	pop	r26
     b0c:	9f 91       	pop	r25
     b0e:	8f 91       	pop	r24
     b10:	7f 91       	pop	r23
     b12:	6f 91       	pop	r22
     b14:	5f 91       	pop	r21
     b16:	4f 91       	pop	r20
     b18:	3f 91       	pop	r19
     b1a:	2f 91       	pop	r18
     b1c:	1f 91       	pop	r17
     b1e:	0f 91       	pop	r16
     b20:	ff 90       	pop	r15
     b22:	ef 90       	pop	r14
     b24:	df 90       	pop	r13
     b26:	cf 90       	pop	r12
     b28:	bf 90       	pop	r11
     b2a:	af 90       	pop	r10
     b2c:	9f 90       	pop	r9
     b2e:	8f 90       	pop	r8
     b30:	7f 90       	pop	r7
     b32:	6f 90       	pop	r6
     b34:	5f 90       	pop	r5
     b36:	4f 90       	pop	r4
     b38:	3f 90       	pop	r3
     b3a:	2f 90       	pop	r2
     b3c:	1f 90       	pop	r1
     b3e:	0f 90       	pop	r0
     b40:	0c be       	out	0x3c, r0	; 60
     b42:	0f 90       	pop	r0
     b44:	0b be       	out	0x3b, r0	; 59
     b46:	0f 90       	pop	r0
     b48:	0f be       	out	0x3f, r0	; 63
     b4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b4c:	08 95       	ret

00000b4e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b4e:	0f 92       	push	r0
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	0f 92       	push	r0
     b56:	0b b6       	in	r0, 0x3b	; 59
     b58:	0f 92       	push	r0
     b5a:	0c b6       	in	r0, 0x3c	; 60
     b5c:	0f 92       	push	r0
     b5e:	1f 92       	push	r1
     b60:	11 24       	eor	r1, r1
     b62:	2f 92       	push	r2
     b64:	3f 92       	push	r3
     b66:	4f 92       	push	r4
     b68:	5f 92       	push	r5
     b6a:	6f 92       	push	r6
     b6c:	7f 92       	push	r7
     b6e:	8f 92       	push	r8
     b70:	9f 92       	push	r9
     b72:	af 92       	push	r10
     b74:	bf 92       	push	r11
     b76:	cf 92       	push	r12
     b78:	df 92       	push	r13
     b7a:	ef 92       	push	r14
     b7c:	ff 92       	push	r15
     b7e:	0f 93       	push	r16
     b80:	1f 93       	push	r17
     b82:	2f 93       	push	r18
     b84:	3f 93       	push	r19
     b86:	4f 93       	push	r20
     b88:	5f 93       	push	r21
     b8a:	6f 93       	push	r22
     b8c:	7f 93       	push	r23
     b8e:	8f 93       	push	r24
     b90:	9f 93       	push	r25
     b92:	af 93       	push	r26
     b94:	bf 93       	push	r27
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	ef 93       	push	r30
     b9c:	ff 93       	push	r31
     b9e:	a0 91 52 1a 	lds	r26, 0x1A52
     ba2:	b0 91 53 1a 	lds	r27, 0x1A53
     ba6:	0d b6       	in	r0, 0x3d	; 61
     ba8:	0d 92       	st	X+, r0
     baa:	0e b6       	in	r0, 0x3e	; 62
     bac:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     bae:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vTaskIncrementTick>
	vTaskSwitchContext();
     bb2:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bb6:	a0 91 52 1a 	lds	r26, 0x1A52
     bba:	b0 91 53 1a 	lds	r27, 0x1A53
     bbe:	cd 91       	ld	r28, X+
     bc0:	cd bf       	out	0x3d, r28	; 61
     bc2:	dd 91       	ld	r29, X+
     bc4:	de bf       	out	0x3e, r29	; 62
     bc6:	ff 91       	pop	r31
     bc8:	ef 91       	pop	r30
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	bf 91       	pop	r27
     bd0:	af 91       	pop	r26
     bd2:	9f 91       	pop	r25
     bd4:	8f 91       	pop	r24
     bd6:	7f 91       	pop	r23
     bd8:	6f 91       	pop	r22
     bda:	5f 91       	pop	r21
     bdc:	4f 91       	pop	r20
     bde:	3f 91       	pop	r19
     be0:	2f 91       	pop	r18
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	ff 90       	pop	r15
     be8:	ef 90       	pop	r14
     bea:	df 90       	pop	r13
     bec:	cf 90       	pop	r12
     bee:	bf 90       	pop	r11
     bf0:	af 90       	pop	r10
     bf2:	9f 90       	pop	r9
     bf4:	8f 90       	pop	r8
     bf6:	7f 90       	pop	r7
     bf8:	6f 90       	pop	r6
     bfa:	5f 90       	pop	r5
     bfc:	4f 90       	pop	r4
     bfe:	3f 90       	pop	r3
     c00:	2f 90       	pop	r2
     c02:	1f 90       	pop	r1
     c04:	0f 90       	pop	r0
     c06:	0c be       	out	0x3c, r0	; 60
     c08:	0f 90       	pop	r0
     c0a:	0b be       	out	0x3b, r0	; 59
     c0c:	0f 90       	pop	r0
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c12:	08 95       	ret

00000c14 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
     c14:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYieldFromTick>
			asm volatile ( "reti" );
     c18:	18 95       	reti

00000c1a <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     c20:	cd 91       	ld	r28, X+
     c22:	dc 91       	ld	r29, X
     c24:	11 97       	sbiw	r26, 0x01	; 1
     c26:	20 97       	sbiw	r28, 0x00	; 0
     c28:	21 f1       	breq	.+72     	; 0xc72 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     c2a:	5c 96       	adiw	r26, 0x1c	; 28
     c2c:	4c 91       	ld	r20, X
     c2e:	5c 97       	sbiw	r26, 0x1c	; 28
     c30:	16 96       	adiw	r26, 0x06	; 6
     c32:	2d 91       	ld	r18, X+
     c34:	3c 91       	ld	r19, X
     c36:	17 97       	sbiw	r26, 0x07	; 7
     c38:	24 0f       	add	r18, r20
     c3a:	31 1d       	adc	r19, r1
     c3c:	17 96       	adiw	r26, 0x07	; 7
     c3e:	3c 93       	st	X, r19
     c40:	2e 93       	st	-X, r18
     c42:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     c44:	12 96       	adiw	r26, 0x02	; 2
     c46:	ed 91       	ld	r30, X+
     c48:	fc 91       	ld	r31, X
     c4a:	13 97       	sbiw	r26, 0x03	; 3
     c4c:	2e 17       	cp	r18, r30
     c4e:	3f 07       	cpc	r19, r31
     c50:	20 f0       	brcs	.+8      	; 0xc5a <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     c52:	17 96       	adiw	r26, 0x07	; 7
     c54:	dc 93       	st	X, r29
     c56:	ce 93       	st	-X, r28
     c58:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     c5a:	16 96       	adiw	r26, 0x06	; 6
     c5c:	3c 91       	ld	r19, X
     c5e:	16 97       	sbiw	r26, 0x06	; 6
     c60:	17 96       	adiw	r26, 0x07	; 7
     c62:	2c 91       	ld	r18, X
     c64:	86 2f       	mov	r24, r22
     c66:	97 2f       	mov	r25, r23
     c68:	63 2f       	mov	r22, r19
     c6a:	72 2f       	mov	r23, r18
     c6c:	50 e0       	ldi	r21, 0x00	; 0
     c6e:	0e 94 2b 10 	call	0x2056	; 0x2056 <memcpy>
	}
}
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	08 95       	ret

00000c78 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     c78:	0f 93       	push	r16
     c7a:	1f 93       	push	r17
     c7c:	cf 93       	push	r28
     c7e:	df 93       	push	r29
     c80:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     c82:	0f b6       	in	r0, 0x3f	; 63
     c84:	f8 94       	cli
     c86:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c88:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c8a:	18 16       	cp	r1, r24
     c8c:	c4 f4       	brge	.+48     	; 0xcbe <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c8e:	89 89       	ldd	r24, Y+17	; 0x11
     c90:	88 23       	and	r24, r24
     c92:	29 f4       	brne	.+10     	; 0xc9e <prvUnlockQueue+0x26>
     c94:	14 c0       	rjmp	.+40     	; 0xcbe <prvUnlockQueue+0x46>
     c96:	89 89       	ldd	r24, Y+17	; 0x11
     c98:	88 23       	and	r24, r24
     c9a:	21 f4       	brne	.+8      	; 0xca4 <prvUnlockQueue+0x2c>
     c9c:	10 c0       	rjmp	.+32     	; 0xcbe <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c9e:	8e 01       	movw	r16, r28
     ca0:	0f 5e       	subi	r16, 0xEF	; 239
     ca2:	1f 4f       	sbci	r17, 0xFF	; 255
     ca4:	c8 01       	movw	r24, r16
     ca6:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
     caa:	88 23       	and	r24, r24
     cac:	11 f0       	breq	.+4      	; 0xcb2 <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     cae:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     cb2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     cb4:	81 50       	subi	r24, 0x01	; 1
     cb6:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     cb8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     cba:	18 16       	cp	r1, r24
     cbc:	64 f3       	brlt	.-40     	; 0xc96 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     cbe:	8f ef       	ldi	r24, 0xFF	; 255
     cc0:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     cc2:	0f 90       	pop	r0
     cc4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ccc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cce:	18 16       	cp	r1, r24
     cd0:	c4 f4       	brge	.+48     	; 0xd02 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cd2:	88 85       	ldd	r24, Y+8	; 0x08
     cd4:	88 23       	and	r24, r24
     cd6:	29 f4       	brne	.+10     	; 0xce2 <prvUnlockQueue+0x6a>
     cd8:	14 c0       	rjmp	.+40     	; 0xd02 <prvUnlockQueue+0x8a>
     cda:	88 85       	ldd	r24, Y+8	; 0x08
     cdc:	88 23       	and	r24, r24
     cde:	21 f4       	brne	.+8      	; 0xce8 <prvUnlockQueue+0x70>
     ce0:	10 c0       	rjmp	.+32     	; 0xd02 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ce2:	8e 01       	movw	r16, r28
     ce4:	08 5f       	subi	r16, 0xF8	; 248
     ce6:	1f 4f       	sbci	r17, 0xFF	; 255
     ce8:	c8 01       	movw	r24, r16
     cea:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
     cee:	88 23       	and	r24, r24
     cf0:	11 f0       	breq	.+4      	; 0xcf6 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
     cf2:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     cf6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cf8:	81 50       	subi	r24, 0x01	; 1
     cfa:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     cfc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cfe:	18 16       	cp	r1, r24
     d00:	64 f3       	brlt	.-40     	; 0xcda <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     d02:	8f ef       	ldi	r24, 0xFF	; 255
     d04:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     d06:	0f 90       	pop	r0
     d08:	0f be       	out	0x3f, r0	; 63
}
     d0a:	df 91       	pop	r29
     d0c:	cf 91       	pop	r28
     d0e:	1f 91       	pop	r17
     d10:	0f 91       	pop	r16
     d12:	08 95       	ret

00000d14 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     d14:	cf 93       	push	r28
     d16:	df 93       	push	r29
     d18:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     d1a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d1c:	22 23       	and	r18, r18
     d1e:	59 f4       	brne	.+22     	; 0xd36 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d20:	88 81       	ld	r24, Y
     d22:	99 81       	ldd	r25, Y+1	; 0x01
     d24:	00 97       	sbiw	r24, 0x00	; 0
     d26:	e1 f5       	brne	.+120    	; 0xda0 <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     d28:	8a 81       	ldd	r24, Y+2	; 0x02
     d2a:	9b 81       	ldd	r25, Y+3	; 0x03
     d2c:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     d30:	1b 82       	std	Y+3, r1	; 0x03
     d32:	1a 82       	std	Y+2, r1	; 0x02
     d34:	35 c0       	rjmp	.+106    	; 0xda0 <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     d36:	44 23       	and	r20, r20
     d38:	b9 f4       	brne	.+46     	; 0xd68 <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d3a:	8c 81       	ldd	r24, Y+4	; 0x04
     d3c:	9d 81       	ldd	r25, Y+5	; 0x05
     d3e:	42 2f       	mov	r20, r18
     d40:	50 e0       	ldi	r21, 0x00	; 0
     d42:	0e 94 2b 10 	call	0x2056	; 0x2056 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     d46:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d48:	8c 81       	ldd	r24, Y+4	; 0x04
     d4a:	9d 81       	ldd	r25, Y+5	; 0x05
     d4c:	82 0f       	add	r24, r18
     d4e:	91 1d       	adc	r25, r1
     d50:	9d 83       	std	Y+5, r25	; 0x05
     d52:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     d54:	2a 81       	ldd	r18, Y+2	; 0x02
     d56:	3b 81       	ldd	r19, Y+3	; 0x03
     d58:	82 17       	cp	r24, r18
     d5a:	93 07       	cpc	r25, r19
     d5c:	08 f1       	brcs	.+66     	; 0xda0 <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     d5e:	88 81       	ld	r24, Y
     d60:	99 81       	ldd	r25, Y+1	; 0x01
     d62:	9d 83       	std	Y+5, r25	; 0x05
     d64:	8c 83       	std	Y+4, r24	; 0x04
     d66:	1c c0       	rjmp	.+56     	; 0xda0 <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     d68:	8e 81       	ldd	r24, Y+6	; 0x06
     d6a:	9f 81       	ldd	r25, Y+7	; 0x07
     d6c:	42 2f       	mov	r20, r18
     d6e:	50 e0       	ldi	r21, 0x00	; 0
     d70:	0e 94 2b 10 	call	0x2056	; 0x2056 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     d74:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d76:	50 e0       	ldi	r21, 0x00	; 0
     d78:	50 95       	com	r21
     d7a:	41 95       	neg	r20
     d7c:	5f 4f       	sbci	r21, 0xFF	; 255
     d7e:	8e 81       	ldd	r24, Y+6	; 0x06
     d80:	9f 81       	ldd	r25, Y+7	; 0x07
     d82:	84 0f       	add	r24, r20
     d84:	95 1f       	adc	r25, r21
     d86:	9f 83       	std	Y+7, r25	; 0x07
     d88:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     d8a:	28 81       	ld	r18, Y
     d8c:	39 81       	ldd	r19, Y+1	; 0x01
     d8e:	82 17       	cp	r24, r18
     d90:	93 07       	cpc	r25, r19
     d92:	30 f4       	brcc	.+12     	; 0xda0 <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d94:	8a 81       	ldd	r24, Y+2	; 0x02
     d96:	9b 81       	ldd	r25, Y+3	; 0x03
     d98:	48 0f       	add	r20, r24
     d9a:	59 1f       	adc	r21, r25
     d9c:	5f 83       	std	Y+7, r21	; 0x07
     d9e:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     da0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     da2:	8f 5f       	subi	r24, 0xFF	; 255
     da4:	8a 8f       	std	Y+26, r24	; 0x1a
}
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	08 95       	ret

00000dac <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
     dac:	cf 93       	push	r28
     dae:	df 93       	push	r29
     db0:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     db8:	48 81       	ld	r20, Y
     dba:	59 81       	ldd	r21, Y+1	; 0x01
     dbc:	2b 8d       	ldd	r18, Y+27	; 0x1b
     dbe:	30 e0       	ldi	r19, 0x00	; 0
     dc0:	ec 8d       	ldd	r30, Y+28	; 0x1c
     dc2:	f0 e0       	ldi	r31, 0x00	; 0
     dc4:	2e 9f       	mul	r18, r30
     dc6:	c0 01       	movw	r24, r0
     dc8:	2f 9f       	mul	r18, r31
     dca:	90 0d       	add	r25, r0
     dcc:	3e 9f       	mul	r19, r30
     dce:	90 0d       	add	r25, r0
     dd0:	11 24       	eor	r1, r1
     dd2:	84 0f       	add	r24, r20
     dd4:	95 1f       	adc	r25, r21
     dd6:	9b 83       	std	Y+3, r25	; 0x03
     dd8:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     dda:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     ddc:	5d 83       	std	Y+5, r21	; 0x05
     dde:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     de0:	c9 01       	movw	r24, r18
     de2:	01 97       	sbiw	r24, 0x01	; 1
     de4:	e8 9f       	mul	r30, r24
     de6:	90 01       	movw	r18, r0
     de8:	e9 9f       	mul	r30, r25
     dea:	30 0d       	add	r19, r0
     dec:	f8 9f       	mul	r31, r24
     dee:	30 0d       	add	r19, r0
     df0:	11 24       	eor	r1, r1
     df2:	24 0f       	add	r18, r20
     df4:	35 1f       	adc	r19, r21
     df6:	3f 83       	std	Y+7, r19	; 0x07
     df8:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     dfa:	8f ef       	ldi	r24, 0xFF	; 255
     dfc:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     dfe:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     e00:	66 23       	and	r22, r22
     e02:	61 f4       	brne	.+24     	; 0xe1c <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e04:	88 85       	ldd	r24, Y+8	; 0x08
     e06:	88 23       	and	r24, r24
     e08:	89 f0       	breq	.+34     	; 0xe2c <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     e0a:	ce 01       	movw	r24, r28
     e0c:	08 96       	adiw	r24, 0x08	; 8
     e0e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
     e12:	81 30       	cpi	r24, 0x01	; 1
     e14:	59 f4       	brne	.+22     	; 0xe2c <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
     e16:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
     e1a:	08 c0       	rjmp	.+16     	; 0xe2c <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     e1c:	ce 01       	movw	r24, r28
     e1e:	08 96       	adiw	r24, 0x08	; 8
     e20:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     e24:	ce 01       	movw	r24, r28
     e26:	41 96       	adiw	r24, 0x11	; 17
     e28:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     e2c:	0f 90       	pop	r0
     e2e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	df 91       	pop	r29
     e34:	cf 91       	pop	r28
     e36:	08 95       	ret

00000e38 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
     e40:	18 2f       	mov	r17, r24
     e42:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     e44:	88 23       	and	r24, r24
     e46:	f9 f0       	breq	.+62     	; 0xe86 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     e48:	8f e1       	ldi	r24, 0x1F	; 31
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
     e50:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     e52:	00 97       	sbiw	r24, 0x00	; 0
     e54:	d9 f0       	breq	.+54     	; 0xe8c <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     e56:	01 9f       	mul	r16, r17
     e58:	c0 01       	movw	r24, r0
     e5a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     e5c:	01 96       	adiw	r24, 0x01	; 1
     e5e:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
     e62:	99 83       	std	Y+1, r25	; 0x01
     e64:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     e66:	00 97       	sbiw	r24, 0x00	; 0
     e68:	41 f0       	breq	.+16     	; 0xe7a <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     e6a:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     e6c:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
     e6e:	ce 01       	movw	r24, r28
     e70:	61 e0       	ldi	r22, 0x01	; 1
     e72:	0e 94 d6 06 	call	0xdac	; 0xdac <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     e76:	ce 01       	movw	r24, r28
     e78:	0b c0       	rjmp	.+22     	; 0xe90 <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     e7a:	ce 01       	movw	r24, r28
     e7c:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     e80:	80 e0       	ldi	r24, 0x00	; 0
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	05 c0       	rjmp	.+10     	; 0xe90 <xQueueGenericCreate+0x58>
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	02 c0       	rjmp	.+4      	; 0xe90 <xQueueGenericCreate+0x58>
     e8c:	80 e0       	ldi	r24, 0x00	; 0
     e8e:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	1f 91       	pop	r17
     e96:	0f 91       	pop	r16
     e98:	08 95       	ret

00000e9a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     e9a:	8f 92       	push	r8
     e9c:	9f 92       	push	r9
     e9e:	bf 92       	push	r11
     ea0:	cf 92       	push	r12
     ea2:	df 92       	push	r13
     ea4:	ef 92       	push	r14
     ea6:	ff 92       	push	r15
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <xQueueGenericSend+0x18>
     eb2:	0f 92       	push	r0
     eb4:	0f 92       	push	r0
     eb6:	cd b7       	in	r28, 0x3d	; 61
     eb8:	de b7       	in	r29, 0x3e	; 62
     eba:	8c 01       	movw	r16, r24
     ebc:	4b 01       	movw	r8, r22
     ebe:	5d 83       	std	Y+5, r21	; 0x05
     ec0:	4c 83       	std	Y+4, r20	; 0x04
     ec2:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     ec4:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     ec6:	ee 24       	eor	r14, r14
     ec8:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     eca:	cc 24       	eor	r12, r12
     ecc:	dd 24       	eor	r13, r13
     ece:	68 94       	set
     ed0:	c3 f8       	bld	r12, 3
     ed2:	c8 0e       	add	r12, r24
     ed4:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     ed6:	0f b6       	in	r0, 0x3f	; 63
     ed8:	f8 94       	cli
     eda:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     edc:	f8 01       	movw	r30, r16
     ede:	92 8d       	ldd	r25, Z+26	; 0x1a
     ee0:	83 8d       	ldd	r24, Z+27	; 0x1b
     ee2:	98 17       	cp	r25, r24
     ee4:	a8 f4       	brcc	.+42     	; 0xf10 <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     ee6:	c8 01       	movw	r24, r16
     ee8:	b4 01       	movw	r22, r8
     eea:	4b 2d       	mov	r20, r11
     eec:	0e 94 8a 06 	call	0xd14	; 0xd14 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ef0:	f8 01       	movw	r30, r16
     ef2:	81 89       	ldd	r24, Z+17	; 0x11
     ef4:	88 23       	and	r24, r24
     ef6:	41 f0       	breq	.+16     	; 0xf08 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     ef8:	c8 01       	movw	r24, r16
     efa:	41 96       	adiw	r24, 0x11	; 17
     efc:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
     f00:	81 30       	cpi	r24, 0x01	; 1
     f02:	11 f4       	brne	.+4      	; 0xf08 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     f04:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     f08:	0f 90       	pop	r0
     f0a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	52 c0       	rjmp	.+164    	; 0xfb4 <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     f10:	8c 81       	ldd	r24, Y+4	; 0x04
     f12:	9d 81       	ldd	r25, Y+5	; 0x05
     f14:	00 97       	sbiw	r24, 0x00	; 0
     f16:	21 f4       	brne	.+8      	; 0xf20 <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f18:	0f 90       	pop	r0
     f1a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	4a c0       	rjmp	.+148    	; 0xfb4 <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     f20:	ff 20       	and	r15, r15
     f22:	29 f4       	brne	.+10     	; 0xf2e <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f24:	ce 01       	movw	r24, r28
     f26:	01 96       	adiw	r24, 0x01	; 1
     f28:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f2c:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     f2e:	0f 90       	pop	r0
     f30:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f32:	0e 94 24 0c 	call	0x1848	; 0x1848 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f36:	0f b6       	in	r0, 0x3f	; 63
     f38:	f8 94       	cli
     f3a:	0f 92       	push	r0
     f3c:	f8 01       	movw	r30, r16
     f3e:	85 8d       	ldd	r24, Z+29	; 0x1d
     f40:	8f 3f       	cpi	r24, 0xFF	; 255
     f42:	09 f4       	brne	.+2      	; 0xf46 <xQueueGenericSend+0xac>
     f44:	15 8e       	std	Z+29, r1	; 0x1d
     f46:	f8 01       	movw	r30, r16
     f48:	86 8d       	ldd	r24, Z+30	; 0x1e
     f4a:	8f 3f       	cpi	r24, 0xFF	; 255
     f4c:	09 f4       	brne	.+2      	; 0xf50 <xQueueGenericSend+0xb6>
     f4e:	16 8e       	std	Z+30, r1	; 0x1e
     f50:	0f 90       	pop	r0
     f52:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f54:	ce 01       	movw	r24, r28
     f56:	01 96       	adiw	r24, 0x01	; 1
     f58:	be 01       	movw	r22, r28
     f5a:	6c 5f       	subi	r22, 0xFC	; 252
     f5c:	7f 4f       	sbci	r23, 0xFF	; 255
     f5e:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <xTaskCheckForTimeOut>
     f62:	88 23       	and	r24, r24
     f64:	09 f5       	brne	.+66     	; 0xfa8 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	f8 94       	cli
     f6a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     f6c:	f8 01       	movw	r30, r16
     f6e:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f70:	0f 90       	pop	r0
     f72:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     f74:	f8 01       	movw	r30, r16
     f76:	83 8d       	ldd	r24, Z+27	; 0x1b
     f78:	98 17       	cp	r25, r24
     f7a:	81 f4       	brne	.+32     	; 0xf9c <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f7c:	6c 81       	ldd	r22, Y+4	; 0x04
     f7e:	7d 81       	ldd	r23, Y+5	; 0x05
     f80:	c6 01       	movw	r24, r12
     f82:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f86:	c8 01       	movw	r24, r16
     f88:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     f8c:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>
     f90:	88 23       	and	r24, r24
     f92:	09 f0       	breq	.+2      	; 0xf96 <xQueueGenericSend+0xfc>
     f94:	a0 cf       	rjmp	.-192    	; 0xed6 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     f96:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
     f9a:	9d cf       	rjmp	.-198    	; 0xed6 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f9c:	c8 01       	movw	r24, r16
     f9e:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fa2:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>
     fa6:	97 cf       	rjmp	.-210    	; 0xed6 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     fa8:	c8 01       	movw	r24, r16
     faa:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fae:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     fb2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     fb4:	0f 90       	pop	r0
     fb6:	0f 90       	pop	r0
     fb8:	0f 90       	pop	r0
     fba:	0f 90       	pop	r0
     fbc:	0f 90       	pop	r0
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	1f 91       	pop	r17
     fc4:	0f 91       	pop	r16
     fc6:	ff 90       	pop	r15
     fc8:	ef 90       	pop	r14
     fca:	df 90       	pop	r13
     fcc:	cf 90       	pop	r12
     fce:	bf 90       	pop	r11
     fd0:	9f 90       	pop	r9
     fd2:	8f 90       	pop	r8
     fd4:	08 95       	ret

00000fd6 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     fda:	8f e1       	ldi	r24, 0x1F	; 31
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
     fe2:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     fe4:	00 97       	sbiw	r24, 0x00	; 0
     fe6:	f9 f0       	breq	.+62     	; 0x1026 <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
     fe8:	1b 82       	std	Y+3, r1	; 0x03
     fea:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
     fec:	19 82       	std	Y+1, r1	; 0x01
     fee:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
     ff0:	1d 82       	std	Y+5, r1	; 0x05
     ff2:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
     ff4:	1f 82       	std	Y+7, r1	; 0x07
     ff6:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     ff8:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
     ffa:	81 e0       	ldi	r24, 0x01	; 1
     ffc:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
     ffe:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1000:	8f ef       	ldi	r24, 0xFF	; 255
    1002:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1004:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1006:	ce 01       	movw	r24, r28
    1008:	08 96       	adiw	r24, 0x08	; 8
    100a:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    100e:	ce 01       	movw	r24, r28
    1010:	41 96       	adiw	r24, 0x11	; 17
    1012:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    1016:	ce 01       	movw	r24, r28
    1018:	60 e0       	ldi	r22, 0x00	; 0
    101a:	70 e0       	ldi	r23, 0x00	; 0
    101c:	40 e0       	ldi	r20, 0x00	; 0
    101e:	50 e0       	ldi	r21, 0x00	; 0
    1020:	20 e0       	ldi	r18, 0x00	; 0
    1022:	0e 94 4d 07 	call	0xe9a	; 0xe9a <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1026:	8c 2f       	mov	r24, r28
    1028:	9d 2f       	mov	r25, r29
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	08 95       	ret

00001030 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1030:	0f 93       	push	r16
    1032:	1f 93       	push	r17
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	ec 01       	movw	r28, r24
    103a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    103c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    103e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1040:	98 17       	cp	r25, r24
    1042:	e0 f4       	brcc	.+56     	; 0x107c <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1044:	ce 01       	movw	r24, r28
    1046:	42 2f       	mov	r20, r18
    1048:	0e 94 8a 06 	call	0xd14	; 0xd14 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    104c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    104e:	8f 3f       	cpi	r24, 0xFF	; 255
    1050:	81 f4       	brne	.+32     	; 0x1072 <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1052:	89 89       	ldd	r24, Y+17	; 0x11
    1054:	88 23       	and	r24, r24
    1056:	a1 f0       	breq	.+40     	; 0x1080 <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1058:	ce 01       	movw	r24, r28
    105a:	41 96       	adiw	r24, 0x11	; 17
    105c:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
    1060:	88 23       	and	r24, r24
    1062:	81 f0       	breq	.+32     	; 0x1084 <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    1064:	01 15       	cp	r16, r1
    1066:	11 05       	cpc	r17, r1
    1068:	79 f0       	breq	.+30     	; 0x1088 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	f8 01       	movw	r30, r16
    106e:	80 83       	st	Z, r24
    1070:	0c c0       	rjmp	.+24     	; 0x108a <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1072:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1074:	8f 5f       	subi	r24, 0xFF	; 255
    1076:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1078:	81 e0       	ldi	r24, 0x01	; 1
    107a:	07 c0       	rjmp	.+14     	; 0x108a <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    107c:	80 e0       	ldi	r24, 0x00	; 0
    107e:	05 c0       	rjmp	.+10     	; 0x108a <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1080:	81 e0       	ldi	r24, 0x01	; 1
    1082:	03 c0       	rjmp	.+6      	; 0x108a <xQueueGenericSendFromISR+0x5a>
    1084:	81 e0       	ldi	r24, 0x01	; 1
    1086:	01 c0       	rjmp	.+2      	; 0x108a <xQueueGenericSendFromISR+0x5a>
    1088:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    108a:	df 91       	pop	r29
    108c:	cf 91       	pop	r28
    108e:	1f 91       	pop	r17
    1090:	0f 91       	pop	r16
    1092:	08 95       	ret

00001094 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1094:	8f 92       	push	r8
    1096:	9f 92       	push	r9
    1098:	bf 92       	push	r11
    109a:	cf 92       	push	r12
    109c:	df 92       	push	r13
    109e:	ef 92       	push	r14
    10a0:	ff 92       	push	r15
    10a2:	0f 93       	push	r16
    10a4:	1f 93       	push	r17
    10a6:	cf 93       	push	r28
    10a8:	df 93       	push	r29
    10aa:	00 d0       	rcall	.+0      	; 0x10ac <xQueueGenericReceive+0x18>
    10ac:	0f 92       	push	r0
    10ae:	0f 92       	push	r0
    10b0:	cd b7       	in	r28, 0x3d	; 61
    10b2:	de b7       	in	r29, 0x3e	; 62
    10b4:	8c 01       	movw	r16, r24
    10b6:	4b 01       	movw	r8, r22
    10b8:	5d 83       	std	Y+5, r21	; 0x05
    10ba:	4c 83       	std	Y+4, r20	; 0x04
    10bc:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    10be:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    10c0:	ee 24       	eor	r14, r14
    10c2:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    10c4:	0f 2e       	mov	r0, r31
    10c6:	f1 e1       	ldi	r31, 0x11	; 17
    10c8:	cf 2e       	mov	r12, r31
    10ca:	dd 24       	eor	r13, r13
    10cc:	f0 2d       	mov	r31, r0
    10ce:	c8 0e       	add	r12, r24
    10d0:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    10d2:	0f b6       	in	r0, 0x3f	; 63
    10d4:	f8 94       	cli
    10d6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    10d8:	f8 01       	movw	r30, r16
    10da:	82 8d       	ldd	r24, Z+26	; 0x1a
    10dc:	88 23       	and	r24, r24
    10de:	a1 f1       	breq	.+104    	; 0x1148 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    10e0:	e6 80       	ldd	r14, Z+6	; 0x06
    10e2:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    10e4:	c8 01       	movw	r24, r16
    10e6:	b4 01       	movw	r22, r8
    10e8:	0e 94 0d 06 	call	0xc1a	; 0xc1a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    10ec:	bb 20       	and	r11, r11
    10ee:	d1 f4       	brne	.+52     	; 0x1124 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    10f0:	f8 01       	movw	r30, r16
    10f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    10f4:	81 50       	subi	r24, 0x01	; 1
    10f6:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    10f8:	80 81       	ld	r24, Z
    10fa:	91 81       	ldd	r25, Z+1	; 0x01
    10fc:	00 97       	sbiw	r24, 0x00	; 0
    10fe:	29 f4       	brne	.+10     	; 0x110a <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1100:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xTaskGetCurrentTaskHandle>
    1104:	f8 01       	movw	r30, r16
    1106:	93 83       	std	Z+3, r25	; 0x03
    1108:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    110a:	f8 01       	movw	r30, r16
    110c:	80 85       	ldd	r24, Z+8	; 0x08
    110e:	88 23       	and	r24, r24
    1110:	b9 f0       	breq	.+46     	; 0x1140 <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1112:	c8 01       	movw	r24, r16
    1114:	08 96       	adiw	r24, 0x08	; 8
    1116:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
    111a:	81 30       	cpi	r24, 0x01	; 1
    111c:	89 f4       	brne	.+34     	; 0x1140 <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    111e:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
    1122:	0e c0       	rjmp	.+28     	; 0x1140 <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1124:	f8 01       	movw	r30, r16
    1126:	f7 82       	std	Z+7, r15	; 0x07
    1128:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    112a:	81 89       	ldd	r24, Z+17	; 0x11
    112c:	88 23       	and	r24, r24
    112e:	41 f0       	breq	.+16     	; 0x1140 <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1130:	c8 01       	movw	r24, r16
    1132:	41 96       	adiw	r24, 0x11	; 17
    1134:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
    1138:	88 23       	and	r24, r24
    113a:	11 f0       	breq	.+4      	; 0x1140 <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    113c:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1140:	0f 90       	pop	r0
    1142:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	5f c0       	rjmp	.+190    	; 0x1206 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1148:	8c 81       	ldd	r24, Y+4	; 0x04
    114a:	9d 81       	ldd	r25, Y+5	; 0x05
    114c:	00 97       	sbiw	r24, 0x00	; 0
    114e:	21 f4       	brne	.+8      	; 0x1158 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1150:	0f 90       	pop	r0
    1152:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1154:	80 e0       	ldi	r24, 0x00	; 0
    1156:	57 c0       	rjmp	.+174    	; 0x1206 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    1158:	ff 20       	and	r15, r15
    115a:	29 f4       	brne	.+10     	; 0x1166 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    115c:	ce 01       	movw	r24, r28
    115e:	01 96       	adiw	r24, 0x01	; 1
    1160:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1164:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    1166:	0f 90       	pop	r0
    1168:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    116a:	0e 94 24 0c 	call	0x1848	; 0x1848 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    116e:	0f b6       	in	r0, 0x3f	; 63
    1170:	f8 94       	cli
    1172:	0f 92       	push	r0
    1174:	f8 01       	movw	r30, r16
    1176:	85 8d       	ldd	r24, Z+29	; 0x1d
    1178:	8f 3f       	cpi	r24, 0xFF	; 255
    117a:	09 f4       	brne	.+2      	; 0x117e <xQueueGenericReceive+0xea>
    117c:	15 8e       	std	Z+29, r1	; 0x1d
    117e:	f8 01       	movw	r30, r16
    1180:	86 8d       	ldd	r24, Z+30	; 0x1e
    1182:	8f 3f       	cpi	r24, 0xFF	; 255
    1184:	09 f4       	brne	.+2      	; 0x1188 <xQueueGenericReceive+0xf4>
    1186:	16 8e       	std	Z+30, r1	; 0x1e
    1188:	0f 90       	pop	r0
    118a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    118c:	ce 01       	movw	r24, r28
    118e:	01 96       	adiw	r24, 0x01	; 1
    1190:	be 01       	movw	r22, r28
    1192:	6c 5f       	subi	r22, 0xFC	; 252
    1194:	7f 4f       	sbci	r23, 0xFF	; 255
    1196:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <xTaskCheckForTimeOut>
    119a:	88 23       	and	r24, r24
    119c:	71 f5       	brne	.+92     	; 0x11fa <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    119e:	0f b6       	in	r0, 0x3f	; 63
    11a0:	f8 94       	cli
    11a2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    11a4:	f8 01       	movw	r30, r16
    11a6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    11a8:	0f 90       	pop	r0
    11aa:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    11ac:	88 23       	and	r24, r24
    11ae:	f9 f4       	brne	.+62     	; 0x11ee <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    11b0:	f8 01       	movw	r30, r16
    11b2:	80 81       	ld	r24, Z
    11b4:	91 81       	ldd	r25, Z+1	; 0x01
    11b6:	00 97       	sbiw	r24, 0x00	; 0
    11b8:	51 f4       	brne	.+20     	; 0x11ce <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    11ba:	0f b6       	in	r0, 0x3f	; 63
    11bc:	f8 94       	cli
    11be:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    11c0:	f8 01       	movw	r30, r16
    11c2:	82 81       	ldd	r24, Z+2	; 0x02
    11c4:	93 81       	ldd	r25, Z+3	; 0x03
    11c6:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    11ca:	0f 90       	pop	r0
    11cc:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    11ce:	6c 81       	ldd	r22, Y+4	; 0x04
    11d0:	7d 81       	ldd	r23, Y+5	; 0x05
    11d2:	c6 01       	movw	r24, r12
    11d4:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    11d8:	c8 01       	movw	r24, r16
    11da:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    11de:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>
    11e2:	88 23       	and	r24, r24
    11e4:	09 f0       	breq	.+2      	; 0x11e8 <xQueueGenericReceive+0x154>
    11e6:	75 cf       	rjmp	.-278    	; 0x10d2 <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    11e8:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
    11ec:	72 cf       	rjmp	.-284    	; 0x10d2 <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    11ee:	c8 01       	movw	r24, r16
    11f0:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    11f4:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>
    11f8:	6c cf       	rjmp	.-296    	; 0x10d2 <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    11fa:	c8 01       	movw	r24, r16
    11fc:	0e 94 3c 06 	call	0xc78	; 0xc78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1200:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1204:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1206:	0f 90       	pop	r0
    1208:	0f 90       	pop	r0
    120a:	0f 90       	pop	r0
    120c:	0f 90       	pop	r0
    120e:	0f 90       	pop	r0
    1210:	df 91       	pop	r29
    1212:	cf 91       	pop	r28
    1214:	1f 91       	pop	r17
    1216:	0f 91       	pop	r16
    1218:	ff 90       	pop	r15
    121a:	ef 90       	pop	r14
    121c:	df 90       	pop	r13
    121e:	cf 90       	pop	r12
    1220:	bf 90       	pop	r11
    1222:	9f 90       	pop	r9
    1224:	8f 90       	pop	r8
    1226:	08 95       	ret

00001228 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	cf 93       	push	r28
    122e:	df 93       	push	r29
    1230:	ec 01       	movw	r28, r24
    1232:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1234:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1236:	88 23       	and	r24, r24
    1238:	f1 f0       	breq	.+60     	; 0x1276 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    123a:	ce 01       	movw	r24, r28
    123c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1240:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1242:	81 50       	subi	r24, 0x01	; 1
    1244:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1246:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1248:	8f 3f       	cpi	r24, 0xFF	; 255
    124a:	81 f4       	brne	.+32     	; 0x126c <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    124c:	88 85       	ldd	r24, Y+8	; 0x08
    124e:	88 23       	and	r24, r24
    1250:	a1 f0       	breq	.+40     	; 0x127a <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1252:	ce 01       	movw	r24, r28
    1254:	08 96       	adiw	r24, 0x08	; 8
    1256:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <xTaskRemoveFromEventList>
    125a:	88 23       	and	r24, r24
    125c:	81 f0       	breq	.+32     	; 0x127e <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    125e:	01 15       	cp	r16, r1
    1260:	11 05       	cpc	r17, r1
    1262:	79 f0       	breq	.+30     	; 0x1282 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	f8 01       	movw	r30, r16
    1268:	80 83       	st	Z, r24
    126a:	0c c0       	rjmp	.+24     	; 0x1284 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    126c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    126e:	8f 5f       	subi	r24, 0xFF	; 255
    1270:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1272:	81 e0       	ldi	r24, 0x01	; 1
    1274:	07 c0       	rjmp	.+14     	; 0x1284 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1276:	80 e0       	ldi	r24, 0x00	; 0
    1278:	05 c0       	rjmp	.+10     	; 0x1284 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	03 c0       	rjmp	.+6      	; 0x1284 <xQueueReceiveFromISR+0x5c>
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	01 c0       	rjmp	.+2      	; 0x1284 <xQueueReceiveFromISR+0x5c>
    1282:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1284:	df 91       	pop	r29
    1286:	cf 91       	pop	r28
    1288:	1f 91       	pop	r17
    128a:	0f 91       	pop	r16
    128c:	08 95       	ret

0000128e <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    128e:	0f b6       	in	r0, 0x3f	; 63
    1290:	f8 94       	cli
    1292:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1294:	fc 01       	movw	r30, r24
    1296:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1298:	0f 90       	pop	r0
    129a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    129c:	08 95       	ret

0000129e <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    129e:	fc 01       	movw	r30, r24
    12a0:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    12a2:	08 95       	ret

000012a4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    12aa:	88 81       	ld	r24, Y
    12ac:	99 81       	ldd	r25, Y+1	; 0x01
    12ae:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <vPortFree>
	vPortFree( pxQueue );
    12b2:	ce 01       	movw	r24, r28
    12b4:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <vPortFree>
}
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	08 95       	ret

000012be <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    12be:	fc 01       	movw	r30, r24
    12c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	91 11       	cpse	r25, r1
    12c6:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    12c8:	08 95       	ret

000012ca <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    12ca:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    12cc:	22 8d       	ldd	r18, Z+26	; 0x1a
    12ce:	81 e0       	ldi	r24, 0x01	; 1
    12d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    12d2:	29 13       	cpse	r18, r25
    12d4:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    12d6:	08 95       	ret

000012d8 <SPI_MasterTransmit>:
void SPI_MasterTransmit(uint8_t data)
{
	//xSemaphoreTake( xMutex, portMAX_DELAY);
	
	//set SS low
	PORTB &= ~(1 << SPI_SS);
    12d8:	28 98       	cbi	0x05, 0	; 5
	//Load data to be transferred
	SPDR = data;
    12da:	8e bd       	out	0x2e, r24	; 46
	//wait for spi interrupt flag to signal complete transfer
	while (!(SPSR & (1 << SPIF))); 
    12dc:	0d b4       	in	r0, 0x2d	; 45
    12de:	07 fe       	sbrs	r0, 7
    12e0:	fd cf       	rjmp	.-6      	; 0x12dc <SPI_MasterTransmit+0x4>
	//Set SS high 
	PORTB |= (1 << SPI_SS);	
    12e2:	28 9a       	sbi	0x05, 0	; 5
	
	//xSemaphoreGive( xMutex );
}
    12e4:	08 95       	ret

000012e6 <SSEG_Set_Brightness>:
//-
//- Description: This function set the brightness of the 
//- display where 255 is off and 0 is on as bright as possible. 
//---------------------------------------------------------------
void SSEG_Set_Brightness(uint8_t val)
{
    12e6:	cf 93       	push	r28
    12e8:	c8 2f       	mov	r28, r24
	SPI_MasterTransmit(SSEG_BRIGHTNESS);	
    12ea:	8a e7       	ldi	r24, 0x7A	; 122
    12ec:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
	SPI_MasterTransmit(val);
    12f0:	8c 2f       	mov	r24, r28
    12f2:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
}
    12f6:	cf 91       	pop	r28
    12f8:	08 95       	ret

000012fa <SPI_MasterInit>:
void SPI_MasterInit(void)
{
	//SPCR |= ((1 << SPE) | (1 << SPIE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0)); 
	//SPSR |=  1 << SPI2X; 
	
	DDRB = ((1 << SPI_SS) | (1 << SPI_MOSI) | (1 << SPI_SCK)); 
    12fa:	87 e0       	ldi	r24, 0x07	; 7
    12fc:	84 b9       	out	0x04, r24	; 4
	//make sure SS is high
	PORTB |= (1 << SPI_SS);
    12fe:	28 9a       	sbi	0x05, 0	; 5

	SPCR =  (0<<SPIE) |	//No interrupts
    1300:	83 e5       	ldi	r24, 0x53	; 83
    1302:	8c bd       	out	0x2c, r24	; 44
			(0<<CPOL) |	//rising leading edge
			(0<<CPHA) |	//sample leading edge
			(1<<SPR1) | //
			(1<<SPR0) ; //clock speed
	
	SPSR =  (0<<SPIF) |	//SPI interrupt flag
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	8d bd       	out	0x2d, r24	; 45
			(0<<WCOL) |	//Write collision flag
			(1<<SPI2X);	//Doubles SPI clock
			
	
	SSEG_Set_Brightness(10);
    1308:	8a e0       	ldi	r24, 0x0A	; 10
    130a:	0e 94 73 09 	call	0x12e6	; 0x12e6 <SSEG_Set_Brightness>
}
    130e:	08 95       	ret

00001310 <SSEG_Reset>:
//-
//- Description: This function turns off all display elements. 
//---------------------------------------------------------------
void SSEG_Reset(void)
{
	SPI_MasterTransmit(SSEG_RESET);	
    1310:	86 e7       	ldi	r24, 0x76	; 118
    1312:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
}
    1316:	08 95       	ret

00001318 <SSEG_Write_4vals_array>:
//- pointing to an array of four byte values, one for 
//- each of the 7-segment display locations. The four values
//- are then written to the 7-segment display.  
//---------------------------------------------------------------
void SSEG_Write_4vals_array(uint8_t* vals)
{
    1318:	1f 93       	push	r17
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
    131e:	c8 2f       	mov	r28, r24
    1320:	d9 2f       	mov	r29, r25
    1322:	14 e0       	ldi	r17, 0x04	; 4
	uint8_t i;
	for(i = 0; i < 4; i ++)
	{
		SPI_MasterTransmit(*(vals + i));			
    1324:	89 91       	ld	r24, Y+
    1326:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
    132a:	11 50       	subi	r17, 0x01	; 1
//- are then written to the 7-segment display.  
//---------------------------------------------------------------
void SSEG_Write_4vals_array(uint8_t* vals)
{
	uint8_t i;
	for(i = 0; i < 4; i ++)
    132c:	d9 f7       	brne	.-10     	; 0x1324 <SSEG_Write_4vals_array+0xc>
	{
		SPI_MasterTransmit(*(vals + i));			
	}		
}
    132e:	df 91       	pop	r29
    1330:	cf 91       	pop	r28
    1332:	1f 91       	pop	r17
    1334:	08 95       	ret

00001336 <SSEG_Write_digit>:
//- individual digits to the display. In this case, you need 
//- to first send the initial escape character before you 
//- send the actual data. 
//---------------------------------------------------------------
void SSEG_Write_digit(uint8_t digit, uint8_t val)
{
    1336:	cf 93       	push	r28
    1338:	c6 2f       	mov	r28, r22
	switch(digit)
    133a:	82 30       	cpi	r24, 0x02	; 2
    133c:	89 f0       	breq	.+34     	; 0x1360 <SSEG_Write_digit+0x2a>
    133e:	83 30       	cpi	r24, 0x03	; 3
    1340:	18 f4       	brcc	.+6      	; 0x1348 <SSEG_Write_digit+0x12>
    1342:	81 30       	cpi	r24, 0x01	; 1
    1344:	09 f5       	brne	.+66     	; 0x1388 <SSEG_Write_digit+0x52>
    1346:	05 c0       	rjmp	.+10     	; 0x1352 <SSEG_Write_digit+0x1c>
    1348:	83 30       	cpi	r24, 0x03	; 3
    134a:	89 f0       	breq	.+34     	; 0x136e <SSEG_Write_digit+0x38>
    134c:	84 30       	cpi	r24, 0x04	; 4
    134e:	e1 f4       	brne	.+56     	; 0x1388 <SSEG_Write_digit+0x52>
    1350:	15 c0       	rjmp	.+42     	; 0x137c <SSEG_Write_digit+0x46>
	{
		case 1:
			SPI_MasterTransmit(DIGIT_1);
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    1358:	8c 2f       	mov	r24, r28
    135a:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			break; 
    135e:	14 c0       	rjmp	.+40     	; 0x1388 <SSEG_Write_digit+0x52>
		
		case 2:
			SPI_MasterTransmit(DIGIT_2);
    1360:	82 e0       	ldi	r24, 0x02	; 2
    1362:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    1366:	8c 2f       	mov	r24, r28
    1368:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			break;
    136c:	0d c0       	rjmp	.+26     	; 0x1388 <SSEG_Write_digit+0x52>
		
		case 3:
			SPI_MasterTransmit(DIGIT_3);
    136e:	83 e0       	ldi	r24, 0x03	; 3
    1370:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    1374:	8c 2f       	mov	r24, r28
    1376:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			break;
    137a:	06 c0       	rjmp	.+12     	; 0x1388 <SSEG_Write_digit+0x52>
		
		case 4:
			SPI_MasterTransmit(DIGIT_4);
    137c:	84 e0       	ldi	r24, 0x04	; 4
    137e:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			SPI_MasterTransmit(val);
    1382:	8c 2f       	mov	r24, r28
    1384:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
			break;
			
		default:	
			break;
	}	
}
    1388:	cf 91       	pop	r28
    138a:	08 95       	ret

0000138c <SSEG_Write_left_digits>:
//- a tens and ones digit the then sends them off to the two 
//- left-most digits of the display. This function also handles
//- lead zero blanking. 
//---------------------------------------------------------------
void SSEG_Write_left_digits(uint8_t val)
{
    138c:	cf 93       	push	r28
	uint8_t dig_ones_place = val;
	//variable to store the 10's place value once it's determined
	uint8_t dig_tens_place = 0; 
	
	//2 digits of 7seg can display up to 99. Check bounds of 'val'
	if(val < 100)
    138e:	84 36       	cpi	r24, 0x64	; 100
    1390:	48 f4       	brcc	.+18     	; 0x13a4 <SSEG_Write_left_digits+0x18>
	{
		dig_tens_place = val / 10;
    1392:	6a e0       	ldi	r22, 0x0A	; 10
    1394:	0e 94 1f 10 	call	0x203e	; 0x203e <__udivmodqi4>
    1398:	c9 2f       	mov	r28, r25
		dig_ones_place = val % 10;
		
		SPI_MasterTransmit(dig_tens_place);
    139a:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
		SPI_MasterTransmit(dig_ones_place);
    139e:	8c 2f       	mov	r24, r28
    13a0:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
	}		
}
    13a4:	cf 91       	pop	r28
    13a6:	08 95       	ret

000013a8 <SSEG_Write_right_digits>:
//- a tens and ones digit the then sends them off to the two 
//- right-most digits of the display. This function also handles
//- lead zero blanking. 
//---------------------------------------------------------------
void SSEG_Write_right_digits(uint8_t val)
{
    13a8:	cf 93       	push	r28
	uint8_t dig_ones_place = val;
	//variable to store the 10's place value once it's determined
	uint8_t dig_tens_place = 0;
		
	//2 digits of 7seg can display up to 99. Check bounds of 'val'
	if(val < 100)
    13aa:	84 36       	cpi	r24, 0x64	; 100
    13ac:	b0 f4       	brcc	.+44     	; 0x13da <SSEG_Write_right_digits+0x32>
	{
		//subtract from tens place until it's zero to determine
		//tens and ones place digits
		while((dig_ones_place - 10) >= 0)
    13ae:	28 2f       	mov	r18, r24
    13b0:	30 e0       	ldi	r19, 0x00	; 0
    13b2:	2a 50       	subi	r18, 0x0A	; 10
    13b4:	30 40       	sbci	r19, 0x00	; 0
    13b6:	52 f0       	brmi	.+20     	; 0x13cc <SSEG_Write_right_digits+0x24>
    13b8:	c8 2f       	mov	r28, r24
    13ba:	80 e0       	ldi	r24, 0x00	; 0
		{
			dig_ones_place -= 10;
    13bc:	ca 50       	subi	r28, 0x0A	; 10
			dig_tens_place++;
    13be:	8f 5f       	subi	r24, 0xFF	; 255
	//2 digits of 7seg can display up to 99. Check bounds of 'val'
	if(val < 100)
	{
		//subtract from tens place until it's zero to determine
		//tens and ones place digits
		while((dig_ones_place - 10) >= 0)
    13c0:	2c 2f       	mov	r18, r28
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    13c4:	2a 50       	subi	r18, 0x0A	; 10
    13c6:	30 40       	sbci	r19, 0x00	; 0
    13c8:	ca f7       	brpl	.-14     	; 0x13bc <SSEG_Write_right_digits+0x14>
    13ca:	02 c0       	rjmp	.+4      	; 0x13d0 <SSEG_Write_right_digits+0x28>
    13cc:	c8 2f       	mov	r28, r24
    13ce:	80 e0       	ldi	r24, 0x00	; 0
		{
			dig_ones_place -= 10;
			dig_tens_place++;
		}
		SPI_MasterTransmit(dig_tens_place);
    13d0:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
		SPI_MasterTransmit(dig_ones_place);
    13d4:	8c 2f       	mov	r24, r28
    13d6:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
	}	
}
    13da:	cf 91       	pop	r28
    13dc:	08 95       	ret

000013de <SSEG_Write_Decimal_Point>:
//- Description: Writes decimal point values to the display. 
//- There are six different values that can be written. Check 
//- out the 7-segment device spec for details on decimal points.
//---------------------------------------------------------------
void SSEG_Write_Decimal_Point(uint8_t val)
{
    13de:	cf 93       	push	r28
    13e0:	c8 2f       	mov	r28, r24
	SPI_MasterTransmit(SSEG_DEC_PNT);
    13e2:	87 e7       	ldi	r24, 0x77	; 119
    13e4:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
	SPI_MasterTransmit(val);
    13e8:	8c 2f       	mov	r24, r28
    13ea:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <SPI_MasterTransmit>
}
    13ee:	cf 91       	pop	r28
    13f0:	08 95       	ret

000013f2 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    13f2:	cf 93       	push	r28
    13f4:	df 93       	push	r29
    13f6:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    13f8:	e0 91 52 1a 	lds	r30, 0x1A52
    13fc:	f0 91 53 1a 	lds	r31, 0x1A53
    1400:	93 83       	std	Z+3, r25	; 0x03
    1402:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1404:	80 91 5a 1a 	lds	r24, 0x1A5A
    1408:	90 91 5b 1a 	lds	r25, 0x1A5B
    140c:	c8 17       	cp	r28, r24
    140e:	d9 07       	cpc	r29, r25
    1410:	68 f4       	brcc	.+26     	; 0x142c <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1412:	80 91 5d 1a 	lds	r24, 0x1A5D
    1416:	90 91 5e 1a 	lds	r25, 0x1A5E
    141a:	60 91 52 1a 	lds	r22, 0x1A52
    141e:	70 91 53 1a 	lds	r23, 0x1A53
    1422:	6e 5f       	subi	r22, 0xFE	; 254
    1424:	7f 4f       	sbci	r23, 0xFF	; 255
    1426:	0e 94 0a 04 	call	0x814	; 0x814 <vListInsert>
    142a:	17 c0       	rjmp	.+46     	; 0x145a <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    142c:	80 91 5f 1a 	lds	r24, 0x1A5F
    1430:	90 91 60 1a 	lds	r25, 0x1A60
    1434:	60 91 52 1a 	lds	r22, 0x1A52
    1438:	70 91 53 1a 	lds	r23, 0x1A53
    143c:	6e 5f       	subi	r22, 0xFE	; 254
    143e:	7f 4f       	sbci	r23, 0xFF	; 255
    1440:	0e 94 0a 04 	call	0x814	; 0x814 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1444:	80 91 0e 02 	lds	r24, 0x020E
    1448:	90 91 0f 02 	lds	r25, 0x020F
    144c:	c8 17       	cp	r28, r24
    144e:	d9 07       	cpc	r29, r25
    1450:	20 f4       	brcc	.+8      	; 0x145a <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1452:	d0 93 0f 02 	sts	0x020F, r29
    1456:	c0 93 0e 02 	sts	0x020E, r28
		}
	}
}
    145a:	df 91       	pop	r29
    145c:	cf 91       	pop	r28
    145e:	08 95       	ret

00001460 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1460:	c3 e6       	ldi	r28, 0x63	; 99
    1462:	da e1       	ldi	r29, 0x1A	; 26
    1464:	88 81       	ld	r24, Y
    1466:	82 30       	cpi	r24, 0x02	; 2
    1468:	e8 f3       	brcs	.-6      	; 0x1464 <prvIdleTask+0x4>
			{
				taskYIELD();
    146a:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
    146e:	fa cf       	rjmp	.-12     	; 0x1464 <prvIdleTask+0x4>

00001470 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1470:	4f 92       	push	r4
    1472:	5f 92       	push	r5
    1474:	6f 92       	push	r6
    1476:	7f 92       	push	r7
    1478:	8f 92       	push	r8
    147a:	9f 92       	push	r9
    147c:	bf 92       	push	r11
    147e:	cf 92       	push	r12
    1480:	df 92       	push	r13
    1482:	ef 92       	push	r14
    1484:	ff 92       	push	r15
    1486:	0f 93       	push	r16
    1488:	1f 93       	push	r17
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	2c 01       	movw	r4, r24
    1490:	4b 01       	movw	r8, r22
    1492:	ea 01       	movw	r28, r20
    1494:	39 01       	movw	r6, r18
    1496:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1498:	8a e2       	ldi	r24, 0x2A	; 42
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
    14a0:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    14a2:	00 97       	sbiw	r24, 0x00	; 0
    14a4:	09 f4       	brne	.+2      	; 0x14a8 <xTaskGenericCreate+0x38>
    14a6:	e3 c0       	rjmp	.+454    	; 0x166e <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    14a8:	c1 14       	cp	r12, r1
    14aa:	d1 04       	cpc	r13, r1
    14ac:	09 f0       	breq	.+2      	; 0x14b0 <xTaskGenericCreate+0x40>
    14ae:	f4 c0       	rjmp	.+488    	; 0x1698 <xTaskGenericCreate+0x228>
    14b0:	ce 01       	movw	r24, r28
    14b2:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
    14b6:	6c 01       	movw	r12, r24
    14b8:	f8 01       	movw	r30, r16
    14ba:	90 8f       	std	Z+24, r25	; 0x18
    14bc:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    14be:	00 97       	sbiw	r24, 0x00	; 0
    14c0:	29 f4       	brne	.+10     	; 0x14cc <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    14c2:	c8 01       	movw	r24, r16
    14c4:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    14c8:	8f ef       	ldi	r24, 0xFF	; 255
    14ca:	d6 c0       	rjmp	.+428    	; 0x1678 <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    14cc:	c6 01       	movw	r24, r12
    14ce:	65 ea       	ldi	r22, 0xA5	; 165
    14d0:	70 e0       	ldi	r23, 0x00	; 0
    14d2:	ae 01       	movw	r20, r28
    14d4:	0e 94 34 10 	call	0x2068	; 0x2068 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    14d8:	9e 01       	movw	r18, r28
    14da:	21 50       	subi	r18, 0x01	; 1
    14dc:	30 40       	sbci	r19, 0x00	; 0
    14de:	f8 01       	movw	r30, r16
    14e0:	87 89       	ldd	r24, Z+23	; 0x17
    14e2:	90 8d       	ldd	r25, Z+24	; 0x18
    14e4:	6c 01       	movw	r12, r24
    14e6:	c2 0e       	add	r12, r18
    14e8:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    14ea:	c8 01       	movw	r24, r16
    14ec:	49 96       	adiw	r24, 0x19	; 25
    14ee:	b4 01       	movw	r22, r8
    14f0:	40 e1       	ldi	r20, 0x10	; 16
    14f2:	50 e0       	ldi	r21, 0x00	; 0
    14f4:	0e 94 3b 10 	call	0x2076	; 0x2076 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    14f8:	f8 01       	movw	r30, r16
    14fa:	10 a6       	lds	r17, 0xb0
    14fc:	cb 2d       	mov	r28, r11
    14fe:	f3 e0       	ldi	r31, 0x03	; 3
    1500:	fb 15       	cp	r31, r11
    1502:	08 f4       	brcc	.+2      	; 0x1506 <xTaskGenericCreate+0x96>
    1504:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1506:	f8 01       	movw	r30, r16
    1508:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    150a:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    150c:	88 24       	eor	r8, r8
    150e:	99 24       	eor	r9, r9
    1510:	68 94       	set
    1512:	81 f8       	bld	r8, 1
    1514:	80 0e       	add	r8, r16
    1516:	91 1e       	adc	r9, r17
    1518:	c4 01       	movw	r24, r8
    151a:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    151e:	c8 01       	movw	r24, r16
    1520:	0c 96       	adiw	r24, 0x0c	; 12
    1522:	0e 94 dd 03 	call	0x7ba	; 0x7ba <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1526:	f8 01       	movw	r30, r16
    1528:	11 87       	std	Z+9, r17	; 0x09
    152a:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    152c:	84 e0       	ldi	r24, 0x04	; 4
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	8c 1b       	sub	r24, r28
    1532:	91 09       	sbc	r25, r1
    1534:	95 87       	std	Z+13, r25	; 0x0d
    1536:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1538:	13 8b       	std	Z+19, r17	; 0x13
    153a:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    153c:	c6 01       	movw	r24, r12
    153e:	b2 01       	movw	r22, r4
    1540:	a3 01       	movw	r20, r6
    1542:	0e 94 6e 04 	call	0x8dc	; 0x8dc <pxPortInitialiseStack>
    1546:	f8 01       	movw	r30, r16
    1548:	91 83       	std	Z+1, r25	; 0x01
    154a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    154c:	e1 14       	cp	r14, r1
    154e:	f1 04       	cpc	r15, r1
    1550:	19 f0       	breq	.+6      	; 0x1558 <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1552:	f7 01       	movw	r30, r14
    1554:	11 83       	std	Z+1, r17	; 0x01
    1556:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1558:	0f b6       	in	r0, 0x3f	; 63
    155a:	f8 94       	cli
    155c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    155e:	80 91 5c 1a 	lds	r24, 0x1A5C
    1562:	8f 5f       	subi	r24, 0xFF	; 255
    1564:	80 93 5c 1a 	sts	0x1A5C, r24
			if( pxCurrentTCB == NULL )
    1568:	80 91 52 1a 	lds	r24, 0x1A52
    156c:	90 91 53 1a 	lds	r25, 0x1A53
    1570:	00 97       	sbiw	r24, 0x00	; 0
    1572:	d9 f5       	brne	.+118    	; 0x15ea <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1574:	10 93 53 1a 	sts	0x1A53, r17
    1578:	00 93 52 1a 	sts	0x1A52, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    157c:	80 91 5c 1a 	lds	r24, 0x1A5C
    1580:	81 30       	cpi	r24, 0x01	; 1
    1582:	09 f0       	breq	.+2      	; 0x1586 <xTaskGenericCreate+0x116>
    1584:	41 c0       	rjmp	.+130    	; 0x1608 <xTaskGenericCreate+0x198>
    1586:	c0 e0       	ldi	r28, 0x00	; 0
    1588:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    158a:	ce 01       	movw	r24, r28
    158c:	88 0f       	add	r24, r24
    158e:	99 1f       	adc	r25, r25
    1590:	88 0f       	add	r24, r24
    1592:	99 1f       	adc	r25, r25
    1594:	88 0f       	add	r24, r24
    1596:	99 1f       	adc	r25, r25
    1598:	8c 0f       	add	r24, r28
    159a:	9d 1f       	adc	r25, r29
    159c:	8d 59       	subi	r24, 0x9D	; 157
    159e:	95 4e       	sbci	r25, 0xE5	; 229
    15a0:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
    15a4:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    15a6:	c4 30       	cpi	r28, 0x04	; 4
    15a8:	d1 05       	cpc	r29, r1
    15aa:	79 f7       	brne	.-34     	; 0x158a <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    15ac:	c7 e8       	ldi	r28, 0x87	; 135
    15ae:	da e1       	ldi	r29, 0x1A	; 26
    15b0:	ce 01       	movw	r24, r28
    15b2:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    15b6:	0f 2e       	mov	r0, r31
    15b8:	f0 e9       	ldi	r31, 0x90	; 144
    15ba:	ef 2e       	mov	r14, r31
    15bc:	fa e1       	ldi	r31, 0x1A	; 26
    15be:	ff 2e       	mov	r15, r31
    15c0:	f0 2d       	mov	r31, r0
    15c2:	c7 01       	movw	r24, r14
    15c4:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    15c8:	89 e9       	ldi	r24, 0x99	; 153
    15ca:	9a e1       	ldi	r25, 0x1A	; 26
    15cc:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    15d0:	82 ea       	ldi	r24, 0xA2	; 162
    15d2:	9a e1       	ldi	r25, 0x1A	; 26
    15d4:	0e 94 cf 03 	call	0x79e	; 0x79e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    15d8:	d0 93 60 1a 	sts	0x1A60, r29
    15dc:	c0 93 5f 1a 	sts	0x1A5F, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    15e0:	f0 92 5e 1a 	sts	0x1A5E, r15
    15e4:	e0 92 5d 1a 	sts	0x1A5D, r14
    15e8:	0f c0       	rjmp	.+30     	; 0x1608 <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    15ea:	80 91 58 1a 	lds	r24, 0x1A58
    15ee:	88 23       	and	r24, r24
    15f0:	59 f4       	brne	.+22     	; 0x1608 <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    15f2:	e0 91 52 1a 	lds	r30, 0x1A52
    15f6:	f0 91 53 1a 	lds	r31, 0x1A53
    15fa:	86 89       	ldd	r24, Z+22	; 0x16
    15fc:	b8 16       	cp	r11, r24
    15fe:	20 f0       	brcs	.+8      	; 0x1608 <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    1600:	10 93 53 1a 	sts	0x1A53, r17
    1604:	00 93 52 1a 	sts	0x1A52, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1608:	f8 01       	movw	r30, r16
    160a:	86 89       	ldd	r24, Z+22	; 0x16
    160c:	90 91 61 1a 	lds	r25, 0x1A61
    1610:	98 17       	cp	r25, r24
    1612:	10 f4       	brcc	.+4      	; 0x1618 <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1614:	80 93 61 1a 	sts	0x1A61, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1618:	90 91 62 1a 	lds	r25, 0x1A62
    161c:	9f 5f       	subi	r25, 0xFF	; 255
    161e:	90 93 62 1a 	sts	0x1A62, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1622:	90 91 59 1a 	lds	r25, 0x1A59
    1626:	98 17       	cp	r25, r24
    1628:	10 f4       	brcc	.+4      	; 0x162e <xTaskGenericCreate+0x1be>
    162a:	80 93 59 1a 	sts	0x1A59, r24
    162e:	90 e0       	ldi	r25, 0x00	; 0
    1630:	9c 01       	movw	r18, r24
    1632:	22 0f       	add	r18, r18
    1634:	33 1f       	adc	r19, r19
    1636:	22 0f       	add	r18, r18
    1638:	33 1f       	adc	r19, r19
    163a:	22 0f       	add	r18, r18
    163c:	33 1f       	adc	r19, r19
    163e:	82 0f       	add	r24, r18
    1640:	93 1f       	adc	r25, r19
    1642:	8d 59       	subi	r24, 0x9D	; 157
    1644:	95 4e       	sbci	r25, 0xE5	; 229
    1646:	b4 01       	movw	r22, r8
    1648:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    164c:	0f 90       	pop	r0
    164e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1650:	80 91 58 1a 	lds	r24, 0x1A58
    1654:	88 23       	and	r24, r24
    1656:	69 f0       	breq	.+26     	; 0x1672 <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1658:	e0 91 52 1a 	lds	r30, 0x1A52
    165c:	f0 91 53 1a 	lds	r31, 0x1A53
    1660:	86 89       	ldd	r24, Z+22	; 0x16
    1662:	8b 15       	cp	r24, r11
    1664:	40 f4       	brcc	.+16     	; 0x1676 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    1666:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	05 c0       	rjmp	.+10     	; 0x1678 <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    166e:	8f ef       	ldi	r24, 0xFF	; 255
    1670:	03 c0       	rjmp	.+6      	; 0x1678 <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	01 c0       	rjmp	.+2      	; 0x1678 <xTaskGenericCreate+0x208>
    1676:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1678:	df 91       	pop	r29
    167a:	cf 91       	pop	r28
    167c:	1f 91       	pop	r17
    167e:	0f 91       	pop	r16
    1680:	ff 90       	pop	r15
    1682:	ef 90       	pop	r14
    1684:	df 90       	pop	r13
    1686:	cf 90       	pop	r12
    1688:	bf 90       	pop	r11
    168a:	9f 90       	pop	r9
    168c:	8f 90       	pop	r8
    168e:	7f 90       	pop	r7
    1690:	6f 90       	pop	r6
    1692:	5f 90       	pop	r5
    1694:	4f 90       	pop	r4
    1696:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1698:	fc 01       	movw	r30, r24
    169a:	d0 8e       	std	Z+24, r13	; 0x18
    169c:	c7 8a       	std	Z+23, r12	; 0x17
    169e:	16 cf       	rjmp	.-468    	; 0x14cc <xTaskGenericCreate+0x5c>

000016a0 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    16a0:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    16a2:	82 85       	ldd	r24, Z+10	; 0x0a
    16a4:	93 85       	ldd	r25, Z+11	; 0x0b
    16a6:	2a e1       	ldi	r18, 0x1A	; 26
    16a8:	82 3a       	cpi	r24, 0xA2	; 162
    16aa:	92 07       	cpc	r25, r18
    16ac:	61 f4       	brne	.+24     	; 0x16c6 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    16ae:	24 89       	ldd	r18, Z+20	; 0x14
    16b0:	35 89       	ldd	r19, Z+21	; 0x15
    16b2:	8a e1       	ldi	r24, 0x1A	; 26
    16b4:	29 39       	cpi	r18, 0x99	; 153
    16b6:	38 07       	cpc	r19, r24
    16b8:	41 f0       	breq	.+16     	; 0x16ca <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    16ba:	81 e0       	ldi	r24, 0x01	; 1
    16bc:	21 15       	cp	r18, r1
    16be:	31 05       	cpc	r19, r1
    16c0:	29 f0       	breq	.+10     	; 0x16cc <xTaskIsTaskSuspended+0x2c>
    16c2:	80 e0       	ldi	r24, 0x00	; 0
    16c4:	08 95       	ret
    16c6:	80 e0       	ldi	r24, 0x00	; 0
    16c8:	08 95       	ret
    16ca:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    16cc:	08 95       	ret

000016ce <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    16ce:	0f 93       	push	r16
    16d0:	1f 93       	push	r17
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    16d8:	00 97       	sbiw	r24, 0x00	; 0
    16da:	b9 f1       	breq	.+110    	; 0x174a <vTaskResume+0x7c>
    16dc:	80 91 52 1a 	lds	r24, 0x1A52
    16e0:	90 91 53 1a 	lds	r25, 0x1A53
    16e4:	c8 17       	cp	r28, r24
    16e6:	d9 07       	cpc	r29, r25
    16e8:	81 f1       	breq	.+96     	; 0x174a <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    16f0:	ce 01       	movw	r24, r28
    16f2:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <xTaskIsTaskSuspended>
    16f6:	81 30       	cpi	r24, 0x01	; 1
    16f8:	31 f5       	brne	.+76     	; 0x1746 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    16fa:	8e 01       	movw	r16, r28
    16fc:	0e 5f       	subi	r16, 0xFE	; 254
    16fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1700:	c8 01       	movw	r24, r16
    1702:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1706:	8e 89       	ldd	r24, Y+22	; 0x16
    1708:	90 91 59 1a 	lds	r25, 0x1A59
    170c:	98 17       	cp	r25, r24
    170e:	10 f4       	brcc	.+4      	; 0x1714 <vTaskResume+0x46>
    1710:	80 93 59 1a 	sts	0x1A59, r24
    1714:	90 e0       	ldi	r25, 0x00	; 0
    1716:	9c 01       	movw	r18, r24
    1718:	22 0f       	add	r18, r18
    171a:	33 1f       	adc	r19, r19
    171c:	22 0f       	add	r18, r18
    171e:	33 1f       	adc	r19, r19
    1720:	22 0f       	add	r18, r18
    1722:	33 1f       	adc	r19, r19
    1724:	82 0f       	add	r24, r18
    1726:	93 1f       	adc	r25, r19
    1728:	8d 59       	subi	r24, 0x9D	; 157
    172a:	95 4e       	sbci	r25, 0xE5	; 229
    172c:	b8 01       	movw	r22, r16
    172e:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1732:	e0 91 52 1a 	lds	r30, 0x1A52
    1736:	f0 91 53 1a 	lds	r31, 0x1A53
    173a:	9e 89       	ldd	r25, Y+22	; 0x16
    173c:	86 89       	ldd	r24, Z+22	; 0x16
    173e:	98 17       	cp	r25, r24
    1740:	10 f0       	brcs	.+4      	; 0x1746 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    1742:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    1746:	0f 90       	pop	r0
    1748:	0f be       	out	0x3f, r0	; 63
		}
	}
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	1f 91       	pop	r17
    1750:	0f 91       	pop	r16
    1752:	08 95       	ret

00001754 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    1754:	ef 92       	push	r14
    1756:	ff 92       	push	r15
    1758:	1f 93       	push	r17
    175a:	cf 93       	push	r28
    175c:	df 93       	push	r29
    175e:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    1760:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <xTaskIsTaskSuspended>
    1764:	81 30       	cpi	r24, 0x01	; 1
    1766:	b9 f5       	brne	.+110    	; 0x17d6 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1768:	80 91 57 1a 	lds	r24, 0x1A57
    176c:	88 23       	and	r24, r24
    176e:	51 f5       	brne	.+84     	; 0x17c4 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    1770:	e0 91 52 1a 	lds	r30, 0x1A52
    1774:	f0 91 53 1a 	lds	r31, 0x1A53
    1778:	11 e0       	ldi	r17, 0x01	; 1
    177a:	9e 89       	ldd	r25, Y+22	; 0x16
    177c:	86 89       	ldd	r24, Z+22	; 0x16
    177e:	98 17       	cp	r25, r24
    1780:	08 f4       	brcc	.+2      	; 0x1784 <xTaskResumeFromISR+0x30>
    1782:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    1784:	ee 24       	eor	r14, r14
    1786:	ff 24       	eor	r15, r15
    1788:	68 94       	set
    178a:	e1 f8       	bld	r14, 1
    178c:	ec 0e       	add	r14, r28
    178e:	fd 1e       	adc	r15, r29
    1790:	c7 01       	movw	r24, r14
    1792:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1796:	8e 89       	ldd	r24, Y+22	; 0x16
    1798:	90 91 59 1a 	lds	r25, 0x1A59
    179c:	98 17       	cp	r25, r24
    179e:	10 f4       	brcc	.+4      	; 0x17a4 <xTaskResumeFromISR+0x50>
    17a0:	80 93 59 1a 	sts	0x1A59, r24
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	9c 01       	movw	r18, r24
    17a8:	22 0f       	add	r18, r18
    17aa:	33 1f       	adc	r19, r19
    17ac:	22 0f       	add	r18, r18
    17ae:	33 1f       	adc	r19, r19
    17b0:	22 0f       	add	r18, r18
    17b2:	33 1f       	adc	r19, r19
    17b4:	82 0f       	add	r24, r18
    17b6:	93 1f       	adc	r25, r19
    17b8:	8d 59       	subi	r24, 0x9D	; 157
    17ba:	95 4e       	sbci	r25, 0xE5	; 229
    17bc:	b7 01       	movw	r22, r14
    17be:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
    17c2:	0a c0       	rjmp	.+20     	; 0x17d8 <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    17c4:	be 01       	movw	r22, r28
    17c6:	64 5f       	subi	r22, 0xF4	; 244
    17c8:	7f 4f       	sbci	r23, 0xFF	; 255
    17ca:	89 e9       	ldi	r24, 0x99	; 153
    17cc:	9a e1       	ldi	r25, 0x1A	; 26
    17ce:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    17d2:	10 e0       	ldi	r17, 0x00	; 0
    17d4:	01 c0       	rjmp	.+2      	; 0x17d8 <xTaskResumeFromISR+0x84>
    17d6:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    17d8:	81 2f       	mov	r24, r17
    17da:	df 91       	pop	r29
    17dc:	cf 91       	pop	r28
    17de:	1f 91       	pop	r17
    17e0:	ff 90       	pop	r15
    17e2:	ef 90       	pop	r14
    17e4:	08 95       	ret

000017e6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    17e6:	af 92       	push	r10
    17e8:	bf 92       	push	r11
    17ea:	cf 92       	push	r12
    17ec:	df 92       	push	r13
    17ee:	ef 92       	push	r14
    17f0:	ff 92       	push	r15
    17f2:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    17f4:	80 e3       	ldi	r24, 0x30	; 48
    17f6:	9a e0       	ldi	r25, 0x0A	; 10
    17f8:	69 e0       	ldi	r22, 0x09	; 9
    17fa:	72 e0       	ldi	r23, 0x02	; 2
    17fc:	45 e5       	ldi	r20, 0x55	; 85
    17fe:	50 e0       	ldi	r21, 0x00	; 0
    1800:	20 e0       	ldi	r18, 0x00	; 0
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	00 e0       	ldi	r16, 0x00	; 0
    1806:	ee 24       	eor	r14, r14
    1808:	ff 24       	eor	r15, r15
    180a:	cc 24       	eor	r12, r12
    180c:	dd 24       	eor	r13, r13
    180e:	aa 24       	eor	r10, r10
    1810:	bb 24       	eor	r11, r11
    1812:	0e 94 38 0a 	call	0x1470	; 0x1470 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1816:	81 30       	cpi	r24, 0x01	; 1
    1818:	49 f4       	brne	.+18     	; 0x182c <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    181a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    181c:	80 93 58 1a 	sts	0x1A58, r24
		xTickCount = ( portTickType ) 0U;
    1820:	10 92 5b 1a 	sts	0x1A5B, r1
    1824:	10 92 5a 1a 	sts	0x1A5A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1828:	0e 94 07 05 	call	0xa0e	; 0xa0e <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    182c:	0f 91       	pop	r16
    182e:	ff 90       	pop	r15
    1830:	ef 90       	pop	r14
    1832:	df 90       	pop	r13
    1834:	cf 90       	pop	r12
    1836:	bf 90       	pop	r11
    1838:	af 90       	pop	r10
    183a:	08 95       	ret

0000183c <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    183c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    183e:	10 92 58 1a 	sts	0x1A58, r1
	vPortEndScheduler();
    1842:	0e 94 45 05 	call	0xa8a	; 0xa8a <vPortEndScheduler>
}
    1846:	08 95       	ret

00001848 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1848:	80 91 57 1a 	lds	r24, 0x1A57
    184c:	8f 5f       	subi	r24, 0xFF	; 255
    184e:	80 93 57 1a 	sts	0x1A57, r24
}
    1852:	08 95       	ret

00001854 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1854:	0f b6       	in	r0, 0x3f	; 63
    1856:	f8 94       	cli
    1858:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    185a:	80 91 5a 1a 	lds	r24, 0x1A5A
    185e:	90 91 5b 1a 	lds	r25, 0x1A5B
	}
	taskEXIT_CRITICAL();
    1862:	0f 90       	pop	r0
    1864:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1866:	08 95       	ret

00001868 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1868:	80 91 5a 1a 	lds	r24, 0x1A5A
    186c:	90 91 5b 1a 	lds	r25, 0x1A5B
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1870:	08 95       	ret

00001872 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1872:	80 91 5c 1a 	lds	r24, 0x1A5C
}
    1876:	08 95       	ret

00001878 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1878:	0f 93       	push	r16
    187a:	1f 93       	push	r17
    187c:	cf 93       	push	r28
    187e:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1880:	80 91 57 1a 	lds	r24, 0x1A57
    1884:	88 23       	and	r24, r24
    1886:	09 f0       	breq	.+2      	; 0x188a <vTaskIncrementTick+0x12>
    1888:	b3 c0       	rjmp	.+358    	; 0x19f0 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    188a:	80 91 5a 1a 	lds	r24, 0x1A5A
    188e:	90 91 5b 1a 	lds	r25, 0x1A5B
    1892:	01 96       	adiw	r24, 0x01	; 1
    1894:	90 93 5b 1a 	sts	0x1A5B, r25
    1898:	80 93 5a 1a 	sts	0x1A5A, r24
		if( xTickCount == ( portTickType ) 0U )
    189c:	80 91 5a 1a 	lds	r24, 0x1A5A
    18a0:	90 91 5b 1a 	lds	r25, 0x1A5B
    18a4:	00 97       	sbiw	r24, 0x00	; 0
    18a6:	99 f5       	brne	.+102    	; 0x190e <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    18a8:	80 91 5f 1a 	lds	r24, 0x1A5F
    18ac:	90 91 60 1a 	lds	r25, 0x1A60
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    18b0:	20 91 5d 1a 	lds	r18, 0x1A5D
    18b4:	30 91 5e 1a 	lds	r19, 0x1A5E
    18b8:	30 93 60 1a 	sts	0x1A60, r19
    18bc:	20 93 5f 1a 	sts	0x1A5F, r18
			pxOverflowDelayedTaskList = pxTemp;
    18c0:	90 93 5e 1a 	sts	0x1A5E, r25
    18c4:	80 93 5d 1a 	sts	0x1A5D, r24
			xNumOfOverflows++;
    18c8:	80 91 54 1a 	lds	r24, 0x1A54
    18cc:	8f 5f       	subi	r24, 0xFF	; 255
    18ce:	80 93 54 1a 	sts	0x1A54, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    18d2:	e0 91 5f 1a 	lds	r30, 0x1A5F
    18d6:	f0 91 60 1a 	lds	r31, 0x1A60
    18da:	80 81       	ld	r24, Z
    18dc:	88 23       	and	r24, r24
    18de:	39 f4       	brne	.+14     	; 0x18ee <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    18e0:	8f ef       	ldi	r24, 0xFF	; 255
    18e2:	9f ef       	ldi	r25, 0xFF	; 255
    18e4:	90 93 0f 02 	sts	0x020F, r25
    18e8:	80 93 0e 02 	sts	0x020E, r24
    18ec:	10 c0       	rjmp	.+32     	; 0x190e <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    18ee:	e0 91 5f 1a 	lds	r30, 0x1A5F
    18f2:	f0 91 60 1a 	lds	r31, 0x1A60
    18f6:	05 80       	ldd	r0, Z+5	; 0x05
    18f8:	f6 81       	ldd	r31, Z+6	; 0x06
    18fa:	e0 2d       	mov	r30, r0
    18fc:	06 80       	ldd	r0, Z+6	; 0x06
    18fe:	f7 81       	ldd	r31, Z+7	; 0x07
    1900:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1902:	82 81       	ldd	r24, Z+2	; 0x02
    1904:	93 81       	ldd	r25, Z+3	; 0x03
    1906:	90 93 0f 02 	sts	0x020F, r25
    190a:	80 93 0e 02 	sts	0x020E, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    190e:	20 91 5a 1a 	lds	r18, 0x1A5A
    1912:	30 91 5b 1a 	lds	r19, 0x1A5B
    1916:	80 91 0e 02 	lds	r24, 0x020E
    191a:	90 91 0f 02 	lds	r25, 0x020F
    191e:	28 17       	cp	r18, r24
    1920:	39 07       	cpc	r19, r25
    1922:	08 f4       	brcc	.+2      	; 0x1926 <vTaskIncrementTick+0xae>
    1924:	6c c0       	rjmp	.+216    	; 0x19fe <vTaskIncrementTick+0x186>
    1926:	e0 91 5f 1a 	lds	r30, 0x1A5F
    192a:	f0 91 60 1a 	lds	r31, 0x1A60
    192e:	80 81       	ld	r24, Z
    1930:	88 23       	and	r24, r24
    1932:	99 f0       	breq	.+38     	; 0x195a <vTaskIncrementTick+0xe2>
    1934:	e0 91 5f 1a 	lds	r30, 0x1A5F
    1938:	f0 91 60 1a 	lds	r31, 0x1A60
    193c:	05 80       	ldd	r0, Z+5	; 0x05
    193e:	f6 81       	ldd	r31, Z+6	; 0x06
    1940:	e0 2d       	mov	r30, r0
    1942:	c6 81       	ldd	r28, Z+6	; 0x06
    1944:	d7 81       	ldd	r29, Z+7	; 0x07
    1946:	8a 81       	ldd	r24, Y+2	; 0x02
    1948:	9b 81       	ldd	r25, Y+3	; 0x03
    194a:	20 91 5a 1a 	lds	r18, 0x1A5A
    194e:	30 91 5b 1a 	lds	r19, 0x1A5B
    1952:	28 17       	cp	r18, r24
    1954:	39 07       	cpc	r19, r25
    1956:	f8 f4       	brcc	.+62     	; 0x1996 <vTaskIncrementTick+0x11e>
    1958:	19 c0       	rjmp	.+50     	; 0x198c <vTaskIncrementTick+0x114>
    195a:	8f ef       	ldi	r24, 0xFF	; 255
    195c:	9f ef       	ldi	r25, 0xFF	; 255
    195e:	90 93 0f 02 	sts	0x020F, r25
    1962:	80 93 0e 02 	sts	0x020E, r24
    1966:	4b c0       	rjmp	.+150    	; 0x19fe <vTaskIncrementTick+0x186>
    1968:	e0 91 5f 1a 	lds	r30, 0x1A5F
    196c:	f0 91 60 1a 	lds	r31, 0x1A60
    1970:	05 80       	ldd	r0, Z+5	; 0x05
    1972:	f6 81       	ldd	r31, Z+6	; 0x06
    1974:	e0 2d       	mov	r30, r0
    1976:	c6 81       	ldd	r28, Z+6	; 0x06
    1978:	d7 81       	ldd	r29, Z+7	; 0x07
    197a:	8a 81       	ldd	r24, Y+2	; 0x02
    197c:	9b 81       	ldd	r25, Y+3	; 0x03
    197e:	20 91 5a 1a 	lds	r18, 0x1A5A
    1982:	30 91 5b 1a 	lds	r19, 0x1A5B
    1986:	28 17       	cp	r18, r24
    1988:	39 07       	cpc	r19, r25
    198a:	28 f4       	brcc	.+10     	; 0x1996 <vTaskIncrementTick+0x11e>
    198c:	90 93 0f 02 	sts	0x020F, r25
    1990:	80 93 0e 02 	sts	0x020E, r24
    1994:	34 c0       	rjmp	.+104    	; 0x19fe <vTaskIncrementTick+0x186>
    1996:	8e 01       	movw	r16, r28
    1998:	0e 5f       	subi	r16, 0xFE	; 254
    199a:	1f 4f       	sbci	r17, 0xFF	; 255
    199c:	c8 01       	movw	r24, r16
    199e:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
    19a2:	8c 89       	ldd	r24, Y+20	; 0x14
    19a4:	9d 89       	ldd	r25, Y+21	; 0x15
    19a6:	00 97       	sbiw	r24, 0x00	; 0
    19a8:	21 f0       	breq	.+8      	; 0x19b2 <vTaskIncrementTick+0x13a>
    19aa:	ce 01       	movw	r24, r28
    19ac:	0c 96       	adiw	r24, 0x0c	; 12
    19ae:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
    19b2:	8e 89       	ldd	r24, Y+22	; 0x16
    19b4:	90 91 59 1a 	lds	r25, 0x1A59
    19b8:	98 17       	cp	r25, r24
    19ba:	10 f4       	brcc	.+4      	; 0x19c0 <vTaskIncrementTick+0x148>
    19bc:	80 93 59 1a 	sts	0x1A59, r24
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	9c 01       	movw	r18, r24
    19c4:	22 0f       	add	r18, r18
    19c6:	33 1f       	adc	r19, r19
    19c8:	22 0f       	add	r18, r18
    19ca:	33 1f       	adc	r19, r19
    19cc:	22 0f       	add	r18, r18
    19ce:	33 1f       	adc	r19, r19
    19d0:	82 0f       	add	r24, r18
    19d2:	93 1f       	adc	r25, r19
    19d4:	8d 59       	subi	r24, 0x9D	; 157
    19d6:	95 4e       	sbci	r25, 0xE5	; 229
    19d8:	b8 01       	movw	r22, r16
    19da:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
    19de:	e0 91 5f 1a 	lds	r30, 0x1A5F
    19e2:	f0 91 60 1a 	lds	r31, 0x1A60
    19e6:	80 81       	ld	r24, Z
    19e8:	88 23       	and	r24, r24
    19ea:	09 f0       	breq	.+2      	; 0x19ee <vTaskIncrementTick+0x176>
    19ec:	bd cf       	rjmp	.-134    	; 0x1968 <vTaskIncrementTick+0xf0>
    19ee:	b5 cf       	rjmp	.-150    	; 0x195a <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    19f0:	80 91 56 1a 	lds	r24, 0x1A56
    19f4:	8f 5f       	subi	r24, 0xFF	; 255
    19f6:	80 93 56 1a 	sts	0x1A56, r24

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
    19fa:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vApplicationTickHook>

	#if ( configUSE_TICK_HOOK == 1 )
	{
		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
    19fe:	80 91 56 1a 	lds	r24, 0x1A56
    1a02:	88 23       	and	r24, r24
    1a04:	11 f4       	brne	.+4      	; 0x1a0a <vTaskIncrementTick+0x192>
		{
			vApplicationTickHook();
    1a06:	0e 94 78 03 	call	0x6f0	; 0x6f0 <vApplicationTickHook>
		}
	}
	#endif
}
    1a0a:	df 91       	pop	r29
    1a0c:	cf 91       	pop	r28
    1a0e:	1f 91       	pop	r17
    1a10:	0f 91       	pop	r16
    1a12:	08 95       	ret

00001a14 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1a14:	af 92       	push	r10
    1a16:	bf 92       	push	r11
    1a18:	cf 92       	push	r12
    1a1a:	df 92       	push	r13
    1a1c:	ef 92       	push	r14
    1a1e:	ff 92       	push	r15
    1a20:	0f 93       	push	r16
    1a22:	1f 93       	push	r17
    1a24:	cf 93       	push	r28
    1a26:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1a28:	0f b6       	in	r0, 0x3f	; 63
    1a2a:	f8 94       	cli
    1a2c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1a2e:	80 91 57 1a 	lds	r24, 0x1A57
    1a32:	81 50       	subi	r24, 0x01	; 1
    1a34:	80 93 57 1a 	sts	0x1A57, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1a38:	80 91 57 1a 	lds	r24, 0x1A57
    1a3c:	88 23       	and	r24, r24
    1a3e:	09 f0       	breq	.+2      	; 0x1a42 <xTaskResumeAll+0x2e>
    1a40:	69 c0       	rjmp	.+210    	; 0x1b14 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1a42:	80 91 5c 1a 	lds	r24, 0x1A5C
    1a46:	88 23       	and	r24, r24
    1a48:	81 f5       	brne	.+96     	; 0x1aaa <xTaskResumeAll+0x96>
    1a4a:	67 c0       	rjmp	.+206    	; 0x1b1a <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1a4c:	d6 01       	movw	r26, r12
    1a4e:	ed 91       	ld	r30, X+
    1a50:	fc 91       	ld	r31, X
    1a52:	c6 81       	ldd	r28, Z+6	; 0x06
    1a54:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    1a56:	ce 01       	movw	r24, r28
    1a58:	0c 96       	adiw	r24, 0x0c	; 12
    1a5a:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    1a5e:	8e 01       	movw	r16, r28
    1a60:	0e 5f       	subi	r16, 0xFE	; 254
    1a62:	1f 4f       	sbci	r17, 0xFF	; 255
    1a64:	c8 01       	movw	r24, r16
    1a66:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1a6a:	8e 89       	ldd	r24, Y+22	; 0x16
    1a6c:	90 91 59 1a 	lds	r25, 0x1A59
    1a70:	98 17       	cp	r25, r24
    1a72:	10 f4       	brcc	.+4      	; 0x1a78 <xTaskResumeAll+0x64>
    1a74:	80 93 59 1a 	sts	0x1A59, r24
    1a78:	90 e0       	ldi	r25, 0x00	; 0
    1a7a:	9c 01       	movw	r18, r24
    1a7c:	22 0f       	add	r18, r18
    1a7e:	33 1f       	adc	r19, r19
    1a80:	22 0f       	add	r18, r18
    1a82:	33 1f       	adc	r19, r19
    1a84:	22 0f       	add	r18, r18
    1a86:	33 1f       	adc	r19, r19
    1a88:	82 0f       	add	r24, r18
    1a8a:	93 1f       	adc	r25, r19
    1a8c:	8d 59       	subi	r24, 0x9D	; 157
    1a8e:	95 4e       	sbci	r25, 0xE5	; 229
    1a90:	b8 01       	movw	r22, r16
    1a92:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1a96:	e0 91 52 1a 	lds	r30, 0x1A52
    1a9a:	f0 91 53 1a 	lds	r31, 0x1A53
    1a9e:	9e 89       	ldd	r25, Y+22	; 0x16
    1aa0:	86 89       	ldd	r24, Z+22	; 0x16
    1aa2:	98 17       	cp	r25, r24
    1aa4:	88 f0       	brcs	.+34     	; 0x1ac8 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    1aa6:	ba 2c       	mov	r11, r10
    1aa8:	0f c0       	rjmp	.+30     	; 0x1ac8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1aaa:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1aac:	0f 2e       	mov	r0, r31
    1aae:	f9 e9       	ldi	r31, 0x99	; 153
    1ab0:	ef 2e       	mov	r14, r31
    1ab2:	fa e1       	ldi	r31, 0x1A	; 26
    1ab4:	ff 2e       	mov	r15, r31
    1ab6:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1ab8:	0f 2e       	mov	r0, r31
    1aba:	fe e9       	ldi	r31, 0x9E	; 158
    1abc:	cf 2e       	mov	r12, r31
    1abe:	fa e1       	ldi	r31, 0x1A	; 26
    1ac0:	df 2e       	mov	r13, r31
    1ac2:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1ac4:	aa 24       	eor	r10, r10
    1ac6:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1ac8:	f7 01       	movw	r30, r14
    1aca:	80 81       	ld	r24, Z
    1acc:	88 23       	and	r24, r24
    1ace:	09 f0       	breq	.+2      	; 0x1ad2 <xTaskResumeAll+0xbe>
    1ad0:	bd cf       	rjmp	.-134    	; 0x1a4c <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ad2:	80 91 56 1a 	lds	r24, 0x1A56
    1ad6:	88 23       	and	r24, r24
    1ad8:	81 f0       	breq	.+32     	; 0x1afa <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ada:	80 91 56 1a 	lds	r24, 0x1A56
    1ade:	88 23       	and	r24, r24
    1ae0:	99 f0       	breq	.+38     	; 0x1b08 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    1ae2:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vTaskIncrementTick>
						--uxMissedTicks;
    1ae6:	80 91 56 1a 	lds	r24, 0x1A56
    1aea:	81 50       	subi	r24, 0x01	; 1
    1aec:	80 93 56 1a 	sts	0x1A56, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1af0:	80 91 56 1a 	lds	r24, 0x1A56
    1af4:	88 23       	and	r24, r24
    1af6:	a9 f7       	brne	.-22     	; 0x1ae2 <xTaskResumeAll+0xce>
    1af8:	07 c0       	rjmp	.+14     	; 0x1b08 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1afa:	f1 e0       	ldi	r31, 0x01	; 1
    1afc:	bf 16       	cp	r11, r31
    1afe:	21 f0       	breq	.+8      	; 0x1b08 <xTaskResumeAll+0xf4>
    1b00:	80 91 55 1a 	lds	r24, 0x1A55
    1b04:	81 30       	cpi	r24, 0x01	; 1
    1b06:	41 f4       	brne	.+16     	; 0x1b18 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1b08:	10 92 55 1a 	sts	0x1A55, r1
					portYIELD_WITHIN_API();
    1b0c:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1b10:	81 e0       	ldi	r24, 0x01	; 1
    1b12:	03 c0       	rjmp	.+6      	; 0x1b1a <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	01 c0       	rjmp	.+2      	; 0x1b1a <xTaskResumeAll+0x106>
    1b18:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1b1a:	0f 90       	pop	r0
    1b1c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1b1e:	df 91       	pop	r29
    1b20:	cf 91       	pop	r28
    1b22:	1f 91       	pop	r17
    1b24:	0f 91       	pop	r16
    1b26:	ff 90       	pop	r15
    1b28:	ef 90       	pop	r14
    1b2a:	df 90       	pop	r13
    1b2c:	cf 90       	pop	r12
    1b2e:	bf 90       	pop	r11
    1b30:	af 90       	pop	r10
    1b32:	08 95       	ret

00001b34 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1b34:	cf 93       	push	r28
    1b36:	df 93       	push	r29
    1b38:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1b3a:	00 97       	sbiw	r24, 0x00	; 0
    1b3c:	b1 f0       	breq	.+44     	; 0x1b6a <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1b3e:	0e 94 24 0c 	call	0x1848	; 0x1848 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1b42:	80 91 5a 1a 	lds	r24, 0x1A5A
    1b46:	90 91 5b 1a 	lds	r25, 0x1A5B
    1b4a:	c8 0f       	add	r28, r24
    1b4c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1b4e:	80 91 52 1a 	lds	r24, 0x1A52
    1b52:	90 91 53 1a 	lds	r25, 0x1A53
    1b56:	02 96       	adiw	r24, 0x02	; 2
    1b58:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b5c:	ce 01       	movw	r24, r28
    1b5e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1b62:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1b66:	88 23       	and	r24, r24
    1b68:	11 f4       	brne	.+4      	; 0x1b6e <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1b6a:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
		}
	}
    1b6e:	df 91       	pop	r29
    1b70:	cf 91       	pop	r28
    1b72:	08 95       	ret

00001b74 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1b74:	0f 93       	push	r16
    1b76:	1f 93       	push	r17
    1b78:	cf 93       	push	r28
    1b7a:	df 93       	push	r29
    1b7c:	8c 01       	movw	r16, r24
    1b7e:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1b80:	0e 94 24 0c 	call	0x1848	; 0x1848 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1b84:	f8 01       	movw	r30, r16
    1b86:	80 81       	ld	r24, Z
    1b88:	91 81       	ldd	r25, Z+1	; 0x01
    1b8a:	c8 0f       	add	r28, r24
    1b8c:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    1b8e:	20 91 5a 1a 	lds	r18, 0x1A5A
    1b92:	30 91 5b 1a 	lds	r19, 0x1A5B
    1b96:	28 17       	cp	r18, r24
    1b98:	39 07       	cpc	r19, r25
    1b9a:	68 f4       	brcc	.+26     	; 0x1bb6 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1b9c:	c8 17       	cp	r28, r24
    1b9e:	d9 07       	cpc	r29, r25
    1ba0:	50 f5       	brcc	.+84     	; 0x1bf6 <vTaskDelayUntil+0x82>
    1ba2:	80 91 5a 1a 	lds	r24, 0x1A5A
    1ba6:	90 91 5b 1a 	lds	r25, 0x1A5B
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1baa:	d1 83       	std	Z+1, r29	; 0x01
    1bac:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    1bae:	8c 17       	cp	r24, r28
    1bb0:	9d 07       	cpc	r25, r29
    1bb2:	b0 f4       	brcc	.+44     	; 0x1be0 <vTaskDelayUntil+0x6c>
    1bb4:	0b c0       	rjmp	.+22     	; 0x1bcc <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1bb6:	c8 17       	cp	r28, r24
    1bb8:	d9 07       	cpc	r29, r25
    1bba:	c8 f0       	brcs	.+50     	; 0x1bee <vTaskDelayUntil+0x7a>
    1bbc:	80 91 5a 1a 	lds	r24, 0x1A5A
    1bc0:	90 91 5b 1a 	lds	r25, 0x1A5B
    1bc4:	8c 17       	cp	r24, r28
    1bc6:	9d 07       	cpc	r25, r29
    1bc8:	90 f0       	brcs	.+36     	; 0x1bee <vTaskDelayUntil+0x7a>
    1bca:	15 c0       	rjmp	.+42     	; 0x1bf6 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1bcc:	80 91 52 1a 	lds	r24, 0x1A52
    1bd0:	90 91 53 1a 	lds	r25, 0x1A53
    1bd4:	02 96       	adiw	r24, 0x02	; 2
    1bd6:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1bda:	ce 01       	movw	r24, r28
    1bdc:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1be0:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1be4:	88 23       	and	r24, r24
    1be6:	59 f4       	brne	.+22     	; 0x1bfe <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1be8:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
    1bec:	08 c0       	rjmp	.+16     	; 0x1bfe <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1bee:	f8 01       	movw	r30, r16
    1bf0:	d1 83       	std	Z+1, r29	; 0x01
    1bf2:	c0 83       	st	Z, r28
    1bf4:	eb cf       	rjmp	.-42     	; 0x1bcc <vTaskDelayUntil+0x58>
    1bf6:	f8 01       	movw	r30, r16
    1bf8:	d1 83       	std	Z+1, r29	; 0x01
    1bfa:	c0 83       	st	Z, r28
    1bfc:	f1 cf       	rjmp	.-30     	; 0x1be0 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	08 95       	ret

00001c08 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1c08:	80 91 57 1a 	lds	r24, 0x1A57
    1c0c:	88 23       	and	r24, r24
    1c0e:	99 f4       	brne	.+38     	; 0x1c36 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1c10:	80 91 59 1a 	lds	r24, 0x1A59
    1c14:	90 e0       	ldi	r25, 0x00	; 0
    1c16:	fc 01       	movw	r30, r24
    1c18:	ee 0f       	add	r30, r30
    1c1a:	ff 1f       	adc	r31, r31
    1c1c:	ee 0f       	add	r30, r30
    1c1e:	ff 1f       	adc	r31, r31
    1c20:	ee 0f       	add	r30, r30
    1c22:	ff 1f       	adc	r31, r31
    1c24:	8e 0f       	add	r24, r30
    1c26:	9f 1f       	adc	r25, r31
    1c28:	fc 01       	movw	r30, r24
    1c2a:	ed 59       	subi	r30, 0x9D	; 157
    1c2c:	f5 4e       	sbci	r31, 0xE5	; 229
    1c2e:	80 81       	ld	r24, Z
    1c30:	88 23       	and	r24, r24
    1c32:	29 f0       	breq	.+10     	; 0x1c3e <vTaskSwitchContext+0x36>
    1c34:	1b c0       	rjmp	.+54     	; 0x1c6c <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1c36:	81 e0       	ldi	r24, 0x01	; 1
    1c38:	80 93 55 1a 	sts	0x1A55, r24
    1c3c:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1c3e:	80 91 59 1a 	lds	r24, 0x1A59
    1c42:	81 50       	subi	r24, 0x01	; 1
    1c44:	80 93 59 1a 	sts	0x1A59, r24
    1c48:	80 91 59 1a 	lds	r24, 0x1A59
    1c4c:	90 e0       	ldi	r25, 0x00	; 0
    1c4e:	fc 01       	movw	r30, r24
    1c50:	ee 0f       	add	r30, r30
    1c52:	ff 1f       	adc	r31, r31
    1c54:	ee 0f       	add	r30, r30
    1c56:	ff 1f       	adc	r31, r31
    1c58:	ee 0f       	add	r30, r30
    1c5a:	ff 1f       	adc	r31, r31
    1c5c:	8e 0f       	add	r24, r30
    1c5e:	9f 1f       	adc	r25, r31
    1c60:	fc 01       	movw	r30, r24
    1c62:	ed 59       	subi	r30, 0x9D	; 157
    1c64:	f5 4e       	sbci	r31, 0xE5	; 229
    1c66:	80 81       	ld	r24, Z
    1c68:	88 23       	and	r24, r24
    1c6a:	49 f3       	breq	.-46     	; 0x1c3e <vTaskSwitchContext+0x36>
    1c6c:	80 91 59 1a 	lds	r24, 0x1A59
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	fc 01       	movw	r30, r24
    1c74:	ee 0f       	add	r30, r30
    1c76:	ff 1f       	adc	r31, r31
    1c78:	ee 0f       	add	r30, r30
    1c7a:	ff 1f       	adc	r31, r31
    1c7c:	ee 0f       	add	r30, r30
    1c7e:	ff 1f       	adc	r31, r31
    1c80:	e8 0f       	add	r30, r24
    1c82:	f9 1f       	adc	r31, r25
    1c84:	ed 59       	subi	r30, 0x9D	; 157
    1c86:	f5 4e       	sbci	r31, 0xE5	; 229
    1c88:	a1 81       	ldd	r26, Z+1	; 0x01
    1c8a:	b2 81       	ldd	r27, Z+2	; 0x02
    1c8c:	12 96       	adiw	r26, 0x02	; 2
    1c8e:	0d 90       	ld	r0, X+
    1c90:	bc 91       	ld	r27, X
    1c92:	a0 2d       	mov	r26, r0
    1c94:	b2 83       	std	Z+2, r27	; 0x02
    1c96:	a1 83       	std	Z+1, r26	; 0x01
    1c98:	cf 01       	movw	r24, r30
    1c9a:	03 96       	adiw	r24, 0x03	; 3
    1c9c:	a8 17       	cp	r26, r24
    1c9e:	b9 07       	cpc	r27, r25
    1ca0:	31 f4       	brne	.+12     	; 0x1cae <vTaskSwitchContext+0xa6>
    1ca2:	12 96       	adiw	r26, 0x02	; 2
    1ca4:	8d 91       	ld	r24, X+
    1ca6:	9c 91       	ld	r25, X
    1ca8:	13 97       	sbiw	r26, 0x03	; 3
    1caa:	92 83       	std	Z+2, r25	; 0x02
    1cac:	81 83       	std	Z+1, r24	; 0x01
    1cae:	01 80       	ldd	r0, Z+1	; 0x01
    1cb0:	f2 81       	ldd	r31, Z+2	; 0x02
    1cb2:	e0 2d       	mov	r30, r0
    1cb4:	86 81       	ldd	r24, Z+6	; 0x06
    1cb6:	97 81       	ldd	r25, Z+7	; 0x07
    1cb8:	90 93 53 1a 	sts	0x1A53, r25
    1cbc:	80 93 52 1a 	sts	0x1A52, r24
    1cc0:	08 95       	ret

00001cc2 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1cc2:	ef 92       	push	r14
    1cc4:	ff 92       	push	r15
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1cd0:	0f b6       	in	r0, 0x3f	; 63
    1cd2:	f8 94       	cli
    1cd4:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1cd6:	80 91 52 1a 	lds	r24, 0x1A52
    1cda:	90 91 53 1a 	lds	r25, 0x1A53
    1cde:	e8 16       	cp	r14, r24
    1ce0:	f9 06       	cpc	r15, r25
    1ce2:	21 f0       	breq	.+8      	; 0x1cec <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1ce4:	e1 14       	cp	r14, r1
    1ce6:	f1 04       	cpc	r15, r1
    1ce8:	41 f4       	brne	.+16     	; 0x1cfa <vTaskSuspend+0x38>
    1cea:	02 c0       	rjmp	.+4      	; 0x1cf0 <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    1cec:	ee 24       	eor	r14, r14
    1cee:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1cf0:	c0 91 52 1a 	lds	r28, 0x1A52
    1cf4:	d0 91 53 1a 	lds	r29, 0x1A53
    1cf8:	01 c0       	rjmp	.+2      	; 0x1cfc <vTaskSuspend+0x3a>
    1cfa:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1cfc:	8e 01       	movw	r16, r28
    1cfe:	0e 5f       	subi	r16, 0xFE	; 254
    1d00:	1f 4f       	sbci	r17, 0xFF	; 255
    1d02:	c8 01       	movw	r24, r16
    1d04:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1d08:	8c 89       	ldd	r24, Y+20	; 0x14
    1d0a:	9d 89       	ldd	r25, Y+21	; 0x15
    1d0c:	00 97       	sbiw	r24, 0x00	; 0
    1d0e:	21 f0       	breq	.+8      	; 0x1d18 <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    1d10:	ce 01       	movw	r24, r28
    1d12:	0c 96       	adiw	r24, 0x0c	; 12
    1d14:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1d18:	82 ea       	ldi	r24, 0xA2	; 162
    1d1a:	9a e1       	ldi	r25, 0x1A	; 26
    1d1c:	b8 01       	movw	r22, r16
    1d1e:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1d22:	0f 90       	pop	r0
    1d24:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1d26:	e1 14       	cp	r14, r1
    1d28:	f1 04       	cpc	r15, r1
    1d2a:	a1 f4       	brne	.+40     	; 0x1d54 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    1d2c:	80 91 58 1a 	lds	r24, 0x1A58
    1d30:	88 23       	and	r24, r24
    1d32:	19 f0       	breq	.+6      	; 0x1d3a <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1d34:	0e 94 46 05 	call	0xa8c	; 0xa8c <vPortYield>
    1d38:	0d c0       	rjmp	.+26     	; 0x1d54 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1d3a:	90 91 a2 1a 	lds	r25, 0x1AA2
    1d3e:	80 91 5c 1a 	lds	r24, 0x1A5C
    1d42:	98 17       	cp	r25, r24
    1d44:	29 f4       	brne	.+10     	; 0x1d50 <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1d46:	10 92 53 1a 	sts	0x1A53, r1
    1d4a:	10 92 52 1a 	sts	0x1A52, r1
    1d4e:	02 c0       	rjmp	.+4      	; 0x1d54 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    1d50:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <vTaskSwitchContext>
				}
			}
		}
	}
    1d54:	df 91       	pop	r29
    1d56:	cf 91       	pop	r28
    1d58:	1f 91       	pop	r17
    1d5a:	0f 91       	pop	r16
    1d5c:	ff 90       	pop	r15
    1d5e:	ef 90       	pop	r14
    1d60:	08 95       	ret

00001d62 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1d62:	cf 93       	push	r28
    1d64:	df 93       	push	r29
    1d66:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1d68:	60 91 52 1a 	lds	r22, 0x1A52
    1d6c:	70 91 53 1a 	lds	r23, 0x1A53
    1d70:	64 5f       	subi	r22, 0xF4	; 244
    1d72:	7f 4f       	sbci	r23, 0xFF	; 255
    1d74:	0e 94 0a 04 	call	0x814	; 0x814 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1d78:	80 91 52 1a 	lds	r24, 0x1A52
    1d7c:	90 91 53 1a 	lds	r25, 0x1A53
    1d80:	02 96       	adiw	r24, 0x02	; 2
    1d82:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1d86:	8f ef       	ldi	r24, 0xFF	; 255
    1d88:	cf 3f       	cpi	r28, 0xFF	; 255
    1d8a:	d8 07       	cpc	r29, r24
    1d8c:	59 f4       	brne	.+22     	; 0x1da4 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d8e:	60 91 52 1a 	lds	r22, 0x1A52
    1d92:	70 91 53 1a 	lds	r23, 0x1A53
    1d96:	6e 5f       	subi	r22, 0xFE	; 254
    1d98:	7f 4f       	sbci	r23, 0xFF	; 255
    1d9a:	82 ea       	ldi	r24, 0xA2	; 162
    1d9c:	9a e1       	ldi	r25, 0x1A	; 26
    1d9e:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
    1da2:	08 c0       	rjmp	.+16     	; 0x1db4 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1da4:	80 91 5a 1a 	lds	r24, 0x1A5A
    1da8:	90 91 5b 1a 	lds	r25, 0x1A5B
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1dac:	8c 0f       	add	r24, r28
    1dae:	9d 1f       	adc	r25, r29
    1db0:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    1db4:	df 91       	pop	r29
    1db6:	cf 91       	pop	r28
    1db8:	08 95       	ret

00001dba <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1dba:	0f 93       	push	r16
    1dbc:	1f 93       	push	r17
    1dbe:	cf 93       	push	r28
    1dc0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1dc2:	dc 01       	movw	r26, r24
    1dc4:	15 96       	adiw	r26, 0x05	; 5
    1dc6:	ed 91       	ld	r30, X+
    1dc8:	fc 91       	ld	r31, X
    1dca:	16 97       	sbiw	r26, 0x06	; 6
    1dcc:	06 81       	ldd	r16, Z+6	; 0x06
    1dce:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1dd0:	e8 01       	movw	r28, r16
    1dd2:	2c 96       	adiw	r28, 0x0c	; 12
    1dd4:	ce 01       	movw	r24, r28
    1dd6:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1dda:	80 91 57 1a 	lds	r24, 0x1A57
    1dde:	88 23       	and	r24, r24
    1de0:	e9 f4       	brne	.+58     	; 0x1e1c <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1de2:	e8 01       	movw	r28, r16
    1de4:	22 96       	adiw	r28, 0x02	; 2
    1de6:	ce 01       	movw	r24, r28
    1de8:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1dec:	f8 01       	movw	r30, r16
    1dee:	86 89       	ldd	r24, Z+22	; 0x16
    1df0:	90 91 59 1a 	lds	r25, 0x1A59
    1df4:	98 17       	cp	r25, r24
    1df6:	10 f4       	brcc	.+4      	; 0x1dfc <xTaskRemoveFromEventList+0x42>
    1df8:	80 93 59 1a 	sts	0x1A59, r24
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	9c 01       	movw	r18, r24
    1e00:	22 0f       	add	r18, r18
    1e02:	33 1f       	adc	r19, r19
    1e04:	22 0f       	add	r18, r18
    1e06:	33 1f       	adc	r19, r19
    1e08:	22 0f       	add	r18, r18
    1e0a:	33 1f       	adc	r19, r19
    1e0c:	82 0f       	add	r24, r18
    1e0e:	93 1f       	adc	r25, r19
    1e10:	8d 59       	subi	r24, 0x9D	; 157
    1e12:	95 4e       	sbci	r25, 0xE5	; 229
    1e14:	be 01       	movw	r22, r28
    1e16:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
    1e1a:	05 c0       	rjmp	.+10     	; 0x1e26 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1e1c:	89 e9       	ldi	r24, 0x99	; 153
    1e1e:	9a e1       	ldi	r25, 0x1A	; 26
    1e20:	be 01       	movw	r22, r28
    1e22:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e26:	e0 91 52 1a 	lds	r30, 0x1A52
    1e2a:	f0 91 53 1a 	lds	r31, 0x1A53
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1e2e:	81 e0       	ldi	r24, 0x01	; 1
    1e30:	d8 01       	movw	r26, r16
    1e32:	56 96       	adiw	r26, 0x16	; 22
    1e34:	2c 91       	ld	r18, X
    1e36:	56 97       	sbiw	r26, 0x16	; 22
    1e38:	96 89       	ldd	r25, Z+22	; 0x16
    1e3a:	29 17       	cp	r18, r25
    1e3c:	08 f4       	brcc	.+2      	; 0x1e40 <xTaskRemoveFromEventList+0x86>
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
}
    1e40:	df 91       	pop	r29
    1e42:	cf 91       	pop	r28
    1e44:	1f 91       	pop	r17
    1e46:	0f 91       	pop	r16
    1e48:	08 95       	ret

00001e4a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1e4a:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1e4c:	80 91 54 1a 	lds	r24, 0x1A54
    1e50:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1e52:	80 91 5a 1a 	lds	r24, 0x1A5A
    1e56:	90 91 5b 1a 	lds	r25, 0x1A5B
    1e5a:	92 83       	std	Z+2, r25	; 0x02
    1e5c:	81 83       	std	Z+1, r24	; 0x01
}
    1e5e:	08 95       	ret

00001e60 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1e60:	fc 01       	movw	r30, r24
    1e62:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1e64:	0f b6       	in	r0, 0x3f	; 63
    1e66:	f8 94       	cli
    1e68:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1e6a:	4d 91       	ld	r20, X+
    1e6c:	5c 91       	ld	r21, X
    1e6e:	11 97       	sbiw	r26, 0x01	; 1
    1e70:	6f ef       	ldi	r22, 0xFF	; 255
    1e72:	4f 3f       	cpi	r20, 0xFF	; 255
    1e74:	56 07       	cpc	r21, r22
    1e76:	51 f1       	breq	.+84     	; 0x1ecc <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1e78:	80 91 54 1a 	lds	r24, 0x1A54
    1e7c:	90 81       	ld	r25, Z
    1e7e:	98 17       	cp	r25, r24
    1e80:	49 f0       	breq	.+18     	; 0x1e94 <xTaskCheckForTimeOut+0x34>
    1e82:	20 91 5a 1a 	lds	r18, 0x1A5A
    1e86:	30 91 5b 1a 	lds	r19, 0x1A5B
    1e8a:	81 81       	ldd	r24, Z+1	; 0x01
    1e8c:	92 81       	ldd	r25, Z+2	; 0x02
    1e8e:	28 17       	cp	r18, r24
    1e90:	39 07       	cpc	r19, r25
    1e92:	f0 f4       	brcc	.+60     	; 0x1ed0 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1e94:	80 91 5a 1a 	lds	r24, 0x1A5A
    1e98:	90 91 5b 1a 	lds	r25, 0x1A5B
    1e9c:	21 81       	ldd	r18, Z+1	; 0x01
    1e9e:	32 81       	ldd	r19, Z+2	; 0x02
    1ea0:	82 1b       	sub	r24, r18
    1ea2:	93 0b       	sbc	r25, r19
    1ea4:	84 17       	cp	r24, r20
    1ea6:	95 07       	cpc	r25, r21
    1ea8:	a8 f4       	brcc	.+42     	; 0x1ed4 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1eaa:	80 91 5a 1a 	lds	r24, 0x1A5A
    1eae:	90 91 5b 1a 	lds	r25, 0x1A5B
    1eb2:	b9 01       	movw	r22, r18
    1eb4:	68 1b       	sub	r22, r24
    1eb6:	79 0b       	sbc	r23, r25
    1eb8:	cb 01       	movw	r24, r22
    1eba:	84 0f       	add	r24, r20
    1ebc:	95 1f       	adc	r25, r21
    1ebe:	8d 93       	st	X+, r24
    1ec0:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    1ec2:	cf 01       	movw	r24, r30
    1ec4:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1ec8:	80 e0       	ldi	r24, 0x00	; 0
    1eca:	05 c0       	rjmp	.+10     	; 0x1ed6 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1ecc:	80 e0       	ldi	r24, 0x00	; 0
    1ece:	03 c0       	rjmp	.+6      	; 0x1ed6 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1ed0:	81 e0       	ldi	r24, 0x01	; 1
    1ed2:	01 c0       	rjmp	.+2      	; 0x1ed6 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1eda:	08 95       	ret

00001edc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1edc:	81 e0       	ldi	r24, 0x01	; 1
    1ede:	80 93 55 1a 	sts	0x1A55, r24
}
    1ee2:	08 95       	ret

00001ee4 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1ee4:	00 97       	sbiw	r24, 0x00	; 0
    1ee6:	29 f4       	brne	.+10     	; 0x1ef2 <uxTaskGetStackHighWaterMark+0xe>
    1ee8:	e0 91 52 1a 	lds	r30, 0x1A52
    1eec:	f0 91 53 1a 	lds	r31, 0x1A53
    1ef0:	01 c0       	rjmp	.+2      	; 0x1ef4 <uxTaskGetStackHighWaterMark+0x10>
    1ef2:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1ef4:	07 88       	ldd	r0, Z+23	; 0x17
    1ef6:	f0 8d       	ldd	r31, Z+24	; 0x18
    1ef8:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1efa:	80 81       	ld	r24, Z
    1efc:	85 3a       	cpi	r24, 0xA5	; 165
    1efe:	41 f4       	brne	.+16     	; 0x1f10 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    1f00:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1f02:	80 e0       	ldi	r24, 0x00	; 0
    1f04:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    1f06:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1f08:	21 91       	ld	r18, Z+
    1f0a:	25 3a       	cpi	r18, 0xA5	; 165
    1f0c:	e1 f3       	breq	.-8      	; 0x1f06 <uxTaskGetStackHighWaterMark+0x22>
    1f0e:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1f10:	80 e0       	ldi	r24, 0x00	; 0
    1f12:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    1f14:	08 95       	ret

00001f16 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1f16:	80 91 52 1a 	lds	r24, 0x1A52
    1f1a:	90 91 53 1a 	lds	r25, 0x1A53

		return xReturn;
	}
    1f1e:	08 95       	ret

00001f20 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1f20:	0f 93       	push	r16
    1f22:	1f 93       	push	r17
    1f24:	cf 93       	push	r28
    1f26:	df 93       	push	r29
    1f28:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1f2a:	00 97       	sbiw	r24, 0x00	; 0
    1f2c:	09 f4       	brne	.+2      	; 0x1f30 <vTaskPriorityInherit+0x10>
    1f2e:	4d c0       	rjmp	.+154    	; 0x1fca <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1f30:	8e 89       	ldd	r24, Y+22	; 0x16
    1f32:	e0 91 52 1a 	lds	r30, 0x1A52
    1f36:	f0 91 53 1a 	lds	r31, 0x1A53
    1f3a:	96 89       	ldd	r25, Z+22	; 0x16
    1f3c:	89 17       	cp	r24, r25
    1f3e:	08 f0       	brcs	.+2      	; 0x1f42 <vTaskPriorityInherit+0x22>
    1f40:	44 c0       	rjmp	.+136    	; 0x1fca <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1f42:	e0 91 52 1a 	lds	r30, 0x1A52
    1f46:	f0 91 53 1a 	lds	r31, 0x1A53
    1f4a:	96 89       	ldd	r25, Z+22	; 0x16
    1f4c:	24 e0       	ldi	r18, 0x04	; 4
    1f4e:	30 e0       	ldi	r19, 0x00	; 0
    1f50:	29 1b       	sub	r18, r25
    1f52:	31 09       	sbc	r19, r1
    1f54:	3d 87       	std	Y+13, r19	; 0x0d
    1f56:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1f58:	90 e0       	ldi	r25, 0x00	; 0
    1f5a:	9c 01       	movw	r18, r24
    1f5c:	22 0f       	add	r18, r18
    1f5e:	33 1f       	adc	r19, r19
    1f60:	22 0f       	add	r18, r18
    1f62:	33 1f       	adc	r19, r19
    1f64:	22 0f       	add	r18, r18
    1f66:	33 1f       	adc	r19, r19
    1f68:	82 0f       	add	r24, r18
    1f6a:	93 1f       	adc	r25, r19
    1f6c:	8d 59       	subi	r24, 0x9D	; 157
    1f6e:	95 4e       	sbci	r25, 0xE5	; 229
    1f70:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f72:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f74:	28 17       	cp	r18, r24
    1f76:	39 07       	cpc	r19, r25
    1f78:	11 f5       	brne	.+68     	; 0x1fbe <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1f7a:	8e 01       	movw	r16, r28
    1f7c:	0e 5f       	subi	r16, 0xFE	; 254
    1f7e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f80:	c8 01       	movw	r24, r16
    1f82:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f86:	e0 91 52 1a 	lds	r30, 0x1A52
    1f8a:	f0 91 53 1a 	lds	r31, 0x1A53
    1f8e:	86 89       	ldd	r24, Z+22	; 0x16
    1f90:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    1f92:	90 91 59 1a 	lds	r25, 0x1A59
    1f96:	98 17       	cp	r25, r24
    1f98:	10 f4       	brcc	.+4      	; 0x1f9e <vTaskPriorityInherit+0x7e>
    1f9a:	80 93 59 1a 	sts	0x1A59, r24
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	9c 01       	movw	r18, r24
    1fa2:	22 0f       	add	r18, r18
    1fa4:	33 1f       	adc	r19, r19
    1fa6:	22 0f       	add	r18, r18
    1fa8:	33 1f       	adc	r19, r19
    1faa:	22 0f       	add	r18, r18
    1fac:	33 1f       	adc	r19, r19
    1fae:	82 0f       	add	r24, r18
    1fb0:	93 1f       	adc	r25, r19
    1fb2:	8d 59       	subi	r24, 0x9D	; 157
    1fb4:	95 4e       	sbci	r25, 0xE5	; 229
    1fb6:	b8 01       	movw	r22, r16
    1fb8:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
    1fbc:	06 c0       	rjmp	.+12     	; 0x1fca <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1fbe:	e0 91 52 1a 	lds	r30, 0x1A52
    1fc2:	f0 91 53 1a 	lds	r31, 0x1A53
    1fc6:	86 89       	ldd	r24, Z+22	; 0x16
    1fc8:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    1fca:	df 91       	pop	r29
    1fcc:	cf 91       	pop	r28
    1fce:	1f 91       	pop	r17
    1fd0:	0f 91       	pop	r16
    1fd2:	08 95       	ret

00001fd4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1fd4:	0f 93       	push	r16
    1fd6:	1f 93       	push	r17
    1fd8:	cf 93       	push	r28
    1fda:	df 93       	push	r29
    1fdc:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1fde:	00 97       	sbiw	r24, 0x00	; 0
    1fe0:	49 f1       	breq	.+82     	; 0x2034 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1fe2:	9e 89       	ldd	r25, Y+22	; 0x16
    1fe4:	89 a5       	lds	r24, 0x69
    1fe6:	98 17       	cp	r25, r24
    1fe8:	29 f1       	breq	.+74     	; 0x2034 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1fea:	8e 01       	movw	r16, r28
    1fec:	0e 5f       	subi	r16, 0xFE	; 254
    1fee:	1f 4f       	sbci	r17, 0xFF	; 255
    1ff0:	c8 01       	movw	r24, r16
    1ff2:	0e 94 47 04 	call	0x88e	; 0x88e <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1ff6:	49 a5       	lds	r20, 0x69
    1ff8:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1ffa:	24 2f       	mov	r18, r20
    1ffc:	30 e0       	ldi	r19, 0x00	; 0
    1ffe:	84 e0       	ldi	r24, 0x04	; 4
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	82 1b       	sub	r24, r18
    2004:	93 0b       	sbc	r25, r19
    2006:	9d 87       	std	Y+13, r25	; 0x0d
    2008:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    200a:	80 91 59 1a 	lds	r24, 0x1A59
    200e:	84 17       	cp	r24, r20
    2010:	10 f4       	brcc	.+4      	; 0x2016 <vTaskPriorityDisinherit+0x42>
    2012:	40 93 59 1a 	sts	0x1A59, r20
    2016:	c9 01       	movw	r24, r18
    2018:	88 0f       	add	r24, r24
    201a:	99 1f       	adc	r25, r25
    201c:	88 0f       	add	r24, r24
    201e:	99 1f       	adc	r25, r25
    2020:	88 0f       	add	r24, r24
    2022:	99 1f       	adc	r25, r25
    2024:	28 0f       	add	r18, r24
    2026:	39 1f       	adc	r19, r25
    2028:	c9 01       	movw	r24, r18
    202a:	8d 59       	subi	r24, 0x9D	; 157
    202c:	95 4e       	sbci	r25, 0xE5	; 229
    202e:	b8 01       	movw	r22, r16
    2030:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <vListInsertEnd>
			}
		}
	}
    2034:	df 91       	pop	r29
    2036:	cf 91       	pop	r28
    2038:	1f 91       	pop	r17
    203a:	0f 91       	pop	r16
    203c:	08 95       	ret

0000203e <__udivmodqi4>:
    203e:	99 1b       	sub	r25, r25
    2040:	79 e0       	ldi	r23, 0x09	; 9
    2042:	04 c0       	rjmp	.+8      	; 0x204c <__udivmodqi4_ep>

00002044 <__udivmodqi4_loop>:
    2044:	99 1f       	adc	r25, r25
    2046:	96 17       	cp	r25, r22
    2048:	08 f0       	brcs	.+2      	; 0x204c <__udivmodqi4_ep>
    204a:	96 1b       	sub	r25, r22

0000204c <__udivmodqi4_ep>:
    204c:	88 1f       	adc	r24, r24
    204e:	7a 95       	dec	r23
    2050:	c9 f7       	brne	.-14     	; 0x2044 <__udivmodqi4_loop>
    2052:	80 95       	com	r24
    2054:	08 95       	ret

00002056 <memcpy>:
    2056:	fb 01       	movw	r30, r22
    2058:	dc 01       	movw	r26, r24
    205a:	02 c0       	rjmp	.+4      	; 0x2060 <memcpy+0xa>
    205c:	01 90       	ld	r0, Z+
    205e:	0d 92       	st	X+, r0
    2060:	41 50       	subi	r20, 0x01	; 1
    2062:	50 40       	sbci	r21, 0x00	; 0
    2064:	d8 f7       	brcc	.-10     	; 0x205c <memcpy+0x6>
    2066:	08 95       	ret

00002068 <memset>:
    2068:	dc 01       	movw	r26, r24
    206a:	01 c0       	rjmp	.+2      	; 0x206e <memset+0x6>
    206c:	6d 93       	st	X+, r22
    206e:	41 50       	subi	r20, 0x01	; 1
    2070:	50 40       	sbci	r21, 0x00	; 0
    2072:	e0 f7       	brcc	.-8      	; 0x206c <memset+0x4>
    2074:	08 95       	ret

00002076 <strncpy>:
    2076:	fb 01       	movw	r30, r22
    2078:	dc 01       	movw	r26, r24
    207a:	41 50       	subi	r20, 0x01	; 1
    207c:	50 40       	sbci	r21, 0x00	; 0
    207e:	48 f0       	brcs	.+18     	; 0x2092 <strncpy+0x1c>
    2080:	01 90       	ld	r0, Z+
    2082:	0d 92       	st	X+, r0
    2084:	00 20       	and	r0, r0
    2086:	c9 f7       	brne	.-14     	; 0x207a <strncpy+0x4>
    2088:	01 c0       	rjmp	.+2      	; 0x208c <strncpy+0x16>
    208a:	1d 92       	st	X+, r1
    208c:	41 50       	subi	r20, 0x01	; 1
    208e:	50 40       	sbci	r21, 0x00	; 0
    2090:	e0 f7       	brcc	.-8      	; 0x208a <strncpy+0x14>
    2092:	08 95       	ret

00002094 <_exit>:
    2094:	f8 94       	cli

00002096 <__stop_program>:
    2096:	ff cf       	rjmp	.-2      	; 0x2096 <__stop_program>
