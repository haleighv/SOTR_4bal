/*********************************************************
* File: lab4_main.h
*
* Description: This is a main function that creates tasks
*              using FreeRTOS to:
*		• Blink LED0 at 5 Hz
*			o Count the number of state transitions of 
*			  LED0 and display that number on the two 
*			  left-most digits on the 7-segment display
*				• The count should automatically 
*				  roll over at 99
*		• Blink LED2 at 10 Hz
*			o Count the number of state transitions of 
*			  LED2 and display that number on the two 
*			  right-most digits on the 7-segment display
*				• The count should automatically
*				  roll over at 99
*		• Blink the 7-segment display colon at a rate 
*		  of approximately 1 Hz using the tick hook callback.
*
* Author: Haleigh Vierra, Matt Cruse
*
* Revisions:
*   4/29/2013 HAV Original File Created
*
**********************************************************/
//-------------------Library Includes--------------------//
#include <stdint.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "FreeRTOS.h"
#include "task.h"
#include "init.h"
#include "semphr.h"
#include "spi_sseg.h"
#include "util/delay.h"


//----------------------Definitions----------------------//
#define F_CPU 2000000
#define DELAY_MS_1HZ 500
#define DELAY_MS_2HZ 250
#define DELAY_MS_4HZ 125
#define DELAY_MS_7HZ 71
#define DELAY_MS_8HZ 63
#define DELAY_MS_14HZ 36
#define DEBOUNCE_DELAY 20
#define LED2 2
#define LED0 0

//-----------------Function Prototypes-------------------//
void vTaskFunction_timerHandler(void *pvNada);

//---------------------Globals---------------------------//
extern xSemaphoreHandle xMutex;
xSemaphoreHandle xBinarySemaphore_timer;

//-------------------Main Function-----------------------//
int main( void )
{  	
    // Function initializing PORTA as an output and setting LEDs low
	vIO_init(); 
	//initialize_timer2();
	SPI_MasterInit(); 
	
	
	xMutex = xSemaphoreCreateMutex();
	
	//set SS low
	PORTB &= ~(1 << SPI_SS);
	//Load data to be transferred
	SPDR = 0x00;
	//wait for spi interrupt flag to signal complete transfer
	while (!(SPSR & (1 << SPIF)));
	SPDR = 0x01;
	while (!(SPSR & (1 << SPIF)));
	SPDR = 0x02;
	while (!(SPSR & (1 << SPIF)));
	SPDR = 0x03;
	//Set SS high
	PORTB = (1 << SPI_SS);

	PORTA = 0x00;
	uint8_t i = 0;
	for(;;)
	{
		SSEG_Set_Brightness(i);
		_delay_ms(200);
		i++;
		if(i == 255)
			i = 0;
		
	}
	vSemaphoreCreateBinary( xBinarySemaphore_timer );
	
	// Creates a handler task for the interrupt generated by Timer2 CTC
	xTaskCreate(vTaskFunction_timerHandler, "TMR Task", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
	
    // Start the task scheduler
	vTaskStartScheduler();

	return 0;
}

//----------------Function Definitions-------------------//
/*-----------------------------------------------------
* Function: vTaskFunction_LEDToggle
*
* Description: This task function toggles a specified
*              LED at a specified frequency defined in
*              the array pointed to by 'pvLED_blink_specs'
*
* param a: void *led: pointer to an LED structure. This
*          contains the information of which pin port the
*		   LED is connected and the delay needed to block
*		   the task to run at a desired frequency.
*
* return: void
*--------------------------------------------------------*/



void vTaskFunction_timerHandler(void *pvNada)
{
	static uint8_t task_cnt = 0, sseg_cnt_L = 0, sseg_cnt_R = 0;

	portTickType xLastExecutionTime;
	xLastExecutionTime = xTaskGetTickCount();
	for(;;)
	{	
		//xSemaphoreTake( xBinarySemaphore_timer, portMAX_DELAY );
		PORTA ^= (1 << LED2);//Toggle LED2
		
		SSEG_Write_left_digits(sseg_cnt_L);
		SSEG_Write_right_digits(sseg_cnt_R);
		task_cnt ^= 1;
		if(task_cnt)
		{
			sseg_cnt_L++;
			PORTA ^= (1 << LED0);//Toggle LED0
		}		
		
		if(sseg_cnt_R == 100)
			sseg_cnt_R = 0;
		else
			sseg_cnt_R++;
		
		//TCNT2 = 0;
		vTaskDelayUntil(&xLastExecutionTime, 500/portTICK_RATE_MS);
	}
}

/*-----------------------------------------------------
* Function: ISR for timer2
*
* Description: This Interrupt Service Routine toggles 
*              LED7 and clears timer2's count.
*
* param a: TIMER2_COMPA_vect: vector generated when
*		   timer2 reaches the value held be OCR2A
*--------------------------------------------------------*/
ISR(TIMER2_COMPA_vect)
{
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
	/* 'Give' the semaphore to unblock the task. */
	xSemaphoreGiveFromISR( xBinarySemaphore_timer, &xHigherPriorityTaskWoken );
	if( xHigherPriorityTaskWoken == pdTRUE )
	{
		vPortYield();
	}
}




void vApplicationTickHook( void )
{
	//static uint16_t count = 0;
	//count ++;
	//if(count == 500)
	//{
		//SSEG_Write_Decimal_Point(0x00);
	//}
	//else if(count == 1000)
	//{
		//count = 0;
		//SSEG_Write_Decimal_Point(SSEG_DP_4_val);
	//}		
}